# é¡¹ç›®åç§°ï¼šPhytoOracle MVP

**æ–‡æ¡£ç‰ˆæœ¬**: v1.0
**åˆ›å»ºæ—¶é—´**: 2025-01-11
**ç¼–å†™è€…**: ç³»ç»Ÿæ¶æ„å¸ˆ
**çŠ¶æ€**: è¯„å®¡ä¸­

---

## 1. æ¶æ„æ€»è§ˆ

### 1.1 ç³»ç»Ÿæ¶æ„å›¾

```mermaid
graph TB
    %% å‰ç«¯å±‚
    subgraph Frontend["å‰ç«¯å±‚ (Frontend Layer)"]
        Web["Webè¯Šæ–­ç•Œé¢<br/>(Next.js 15)"]
        Admin["ç®¡ç†åå°<br/>(Streamlit)"]
    end

    %% APIç½‘å…³å±‚
    subgraph Gateway["APIå±‚ (API Gateway)"]
        API["FastAPI Server"]
        Auth["è®¤è¯ä¸­é—´ä»¶<br/>(API Key)"]
    end

    %% ä¸šåŠ¡é€»è¾‘å±‚
    subgraph Business["ä¸šåŠ¡é€»è¾‘å±‚ (Business Logic)"]
        DiagService["è¯Šæ–­æœåŠ¡<br/>(Diagnosis Service)"]
        KnowledgeService["çŸ¥è¯†åº“æœåŠ¡<br/>(Knowledge Service)"]
        ImageService["å›¾ç‰‡æœåŠ¡<br/>(Image Service)"]
    end

    %% é¢†åŸŸæ¨¡å‹å±‚
    subgraph Domain["é¢†åŸŸæ¨¡å‹å±‚ (Domain Models)"]
        DM1["Disease Ontology"]
        DM2["Feature Ontology"]
        DM3["Plant Ontology"]
        DM4["Host-Disease Relations"]
    end

    %% åŸºç¡€è®¾æ–½å±‚
    subgraph Infra["åŸºç¡€è®¾æ–½å±‚ (Infrastructure)"]
        VLM["VLMå®¢æˆ·ç«¯<br/>(Fallbackæœºåˆ¶)"]
        OntologyLoader["çŸ¥è¯†åº“åŠ è½½å™¨<br/>(JSON Loader)"]
        Matcher["æ¨¡ç³ŠåŒ¹é…å¼•æ“"]
        Scorer["åŠ æƒè¯„åˆ†å™¨"]
    end

    %% å¤–éƒ¨æœåŠ¡
    subgraph External["å¤–éƒ¨æœåŠ¡ (External Services)"]
        Qwen["Qwen VL Plus"]
        GPT["ChatGPT<br/>gpt-4o"]
        Grok["Grok Vision"]
        Claude["Claude Sonnet"]
    end

    %% æ•°æ®å­˜å‚¨
    subgraph Storage["æ•°æ®å­˜å‚¨ (Storage)"]
        PG[("PostgreSQL<br/>è¯Šæ–­è®°å½•")]
        Redis[("Redis<br/>ç¼“å­˜")]
        FS[("æ–‡ä»¶ç³»ç»Ÿ<br/>å›¾ç‰‡å­˜å‚¨")]
        Git[("Gitä»“åº“<br/>çŸ¥è¯†åº“JSON")]
    end

    %% è¿æ¥å…³ç³»
    Web --> API
    Admin --> API
    API --> Auth
    Auth --> DiagService
    Auth --> KnowledgeService
    Auth --> ImageService

    DiagService --> VLM
    DiagService --> Scorer
    DiagService --> Domain

    KnowledgeService --> OntologyLoader
    KnowledgeService --> Git

    ImageService --> FS

    VLM --> Qwen
    VLM --> GPT
    VLM --> Grok
    VLM --> Claude

    Scorer --> Matcher
    OntologyLoader --> Git

    DiagService --> PG
    VLM --> Redis
    ImageService --> PG
```

### 1.2 éƒ¨ç½²æ¶æ„å›¾

```mermaid
graph LR
    subgraph Development["å¼€å‘ç¯å¢ƒ"]
        Dev1["åç«¯<br/>python main.py<br/>:8000"]
        Dev2["å‰ç«¯<br/>npm run dev<br/>:3000"]
        Dev3["ç®¡ç†åå°<br/>streamlit run<br/>:8501"]
        Dev4["PostgreSQL<br/>æœ¬åœ°å®‰è£…<br/>:5432"]
        Dev5["Redis<br/>æœ¬åœ°å®‰è£…<br/>:6379"]
    end

    subgraph Production["ç”Ÿäº§ç¯å¢ƒ(äº‘æœåŠ¡å™¨)"]
        Nginx["Nginx<br/>åå‘ä»£ç†<br/>:80/:443"]
        Uvicorn["Uvicorn<br/>å¤šè¿›ç¨‹<br/>:8000-8003"]
        Next["Next.js<br/>Production Build<br/>:3000"]
        StreamlitProd["Streamlit<br/>:8501"]
        PGProd["PostgreSQL<br/>:5432"]
        RedisProd["Redis<br/>:6379"]
    end

    subgraph Users["ç”¨æˆ·è®¿é—®"]
        U1["APIç”¨æˆ·"]
        U2["Webç”¨æˆ·"]
        U3["ç®¡ç†å‘˜"]
    end

    U1 -->|APIè¯·æ±‚| Nginx
    U2 -->|Webè®¿é—®| Nginx
    U3 -->|ç®¡ç†ç•Œé¢| Nginx

    Nginx -->|/api/*| Uvicorn
    Nginx -->|/*| Next
    Nginx -->|/admin/*| StreamlitProd

    Uvicorn --> PGProd
    Uvicorn --> RedisProd
```

### 1.3 æ ¸å¿ƒç±»å›¾

```mermaid
classDiagram
    %% VLMæŠ½è±¡å±‚
    class VLMProvider {
        <<interface>>
        +call(prompt: str, image: bytes) str
        +is_available() bool
        +get_quota() dict
    }

    class QwenProvider {
        +api_key: str
        +base_url: str
        +call(prompt: str, image: bytes) str
    }

    class ChatGPTProvider {
        +api_key: str
        +model: str
        +call(prompt: str, image: bytes) str
    }

    class VLMClient {
        -providers: List[VLMProvider]
        +call_with_fallback(prompt: str, image: bytes) str
        +get_current_provider() str
    }

    VLMProvider <|-- QwenProvider
    VLMProvider <|-- ChatGPTProvider
    VLMClient --> VLMProvider

    %% è¯Šæ–­æœåŠ¡
    class DiagnosisService {
        -vlm_client: VLMClient
        -scorer: DiagnosisScorer
        -knowledge_base: KnowledgeBase
        +diagnose(image: bytes) DiagnosisResult
        -extract_features() FeatureVector
        -match_diseases() List[DiseaseMatch]
    }

    class DiagnosisScorer {
        -matcher: FuzzyMatcher
        +calculate_score(features: dict, disease: dict) float
        +apply_weights(scores: dict) float
    }

    class FuzzyMatcher {
        +COLOR_GROUPS: dict
        +SIZE_ORDER: list
        +match_color(observed: str, expected: str) bool
        +match_size(observed: str, expected: str) bool
    }

    DiagnosisService --> VLMClient
    DiagnosisService --> DiagnosisScorer
    DiagnosisScorer --> FuzzyMatcher

    %% é¢†åŸŸæ¨¡å‹
    class DiseaseOntology {
        +disease_id: str
        +disease_name: str
        +feature_vector: dict
        +feature_importance: dict
        +diagnosis_rules: dict
    }

    class FeatureVector {
        +content_type: str
        +plant_category: str
        +flower_genus: str
        +organ: str
        +completeness: str
        +has_abnormality: str
        +symptom_type: str
        +additional_features: dict
    }

    DiagnosisService --> DiseaseOntology
    DiagnosisService --> FeatureVector
```

---

## 2. é«˜å†…èšä½è€¦åˆè®¾è®¡åŸåˆ™è¯´æ˜

### 2.1 å•ä¸€èŒè´£åŸåˆ™ (SRP)

æ¯ä¸ªæ¨¡å—ä¸¥æ ¼éµå¾ªå•ä¸€èŒè´£ï¼š

| æ¨¡å— | èŒè´£ | ä¸è´Ÿè´£ |
|-----|------|--------|
| **DiagnosisService** | åè°ƒè¯Šæ–­æµç¨‹ | VLMè°ƒç”¨ç»†èŠ‚ã€è¯„åˆ†ç®—æ³• |
| **VLMClient** | VLMè°ƒç”¨ä¸é™çº§ | ä¸šåŠ¡é€»è¾‘ã€Promptç”Ÿæˆ |
| **FuzzyMatcher** | æ¨¡ç³ŠåŒ¹é…é€»è¾‘ | æƒé‡è®¡ç®—ã€è¯Šæ–­å†³ç­– |
| **DiagnosisScorer** | åŠ æƒè¯„åˆ†è®¡ç®— | ç‰¹å¾æå–ã€VLMäº¤äº’ |
| **KnowledgeLoader** | JSONåŠ è½½ä¸ç¼“å­˜ | ä¸šåŠ¡éªŒè¯ã€è¯Šæ–­é€»è¾‘ |
| **ImageService** | å›¾ç‰‡å­˜å‚¨ä¸æ£€ç´¢ | è¯Šæ–­é€»è¾‘ã€VLMè°ƒç”¨ |

### 2.2 ä¾èµ–å€’ç½®åŸåˆ™ (DIP)

é€šè¿‡ProtocolæŠ½è±¡å®ç°ä¾èµ–å€’ç½®ï¼š

```python
from typing import Protocol

# æŠ½è±¡æ¥å£å®šä¹‰
class VLMProtocol(Protocol):
    async def call(self, prompt: str, image: bytes) -> str: ...
    def is_available(self) -> bool: ...

class CacheProtocol(Protocol):
    async def get(self, key: str) -> Optional[str]: ...
    async def set(self, key: str, value: str, ttl: int) -> None: ...

class RepositoryProtocol(Protocol):
    async def save(self, entity: Any) -> str: ...
    async def find_by_id(self, id: str) -> Optional[Any]: ...

# ä¸šåŠ¡å±‚ä¾èµ–æŠ½è±¡ï¼Œè€Œéå…·ä½“å®ç°
class DiagnosisService:
    def __init__(
        self,
        vlm: VLMProtocol,  # ä¾èµ–æŠ½è±¡
        cache: CacheProtocol,  # ä¾èµ–æŠ½è±¡
        repo: RepositoryProtocol  # ä¾èµ–æŠ½è±¡
    ):
        self.vlm = vlm
        self.cache = cache
        self.repo = repo
```

### 2.3 æ¥å£éš”ç¦»åŸåˆ™ (ISP)

ç»†ç²’åº¦æ¥å£è®¾è®¡ï¼Œé¿å…èƒ–æ¥å£ï¼š

```python
# âŒ é”™è¯¯ç¤ºä¾‹ï¼šèƒ–æ¥å£
class KnowledgeService:
    def load_diseases(): ...
    def save_disease(): ...
    def delete_disease(): ...
    def load_plants(): ...
    def save_plant(): ...
    def validate_json(): ...
    def export_to_csv(): ...

# âœ… æ­£ç¡®ç¤ºä¾‹ï¼šç»†ç²’åº¦æ¥å£
class DiseaseLoader(Protocol):
    def load_all() -> List[DiseaseOntology]: ...

class DiseaseEditor(Protocol):
    def save(disease: DiseaseOntology) -> None: ...
    def delete(disease_id: str) -> None: ...

class OntologyValidator(Protocol):
    def validate(json_data: dict) -> ValidationResult: ...
```

### 2.4 å±‚æ¬¡éš”ç¦»

ä¸¥æ ¼çš„å±‚æ¬¡ç»“æ„ï¼Œç¦æ­¢è·¨å±‚è°ƒç”¨ï¼š

```
è¡¨ç°å±‚ (Routers)
    â†“ [ä»…é€šè¿‡Schemaä¼ é€’æ•°æ®]
åº”ç”¨å±‚ (Services)
    â†“ [ä»…é€šè¿‡Domain Modeläº¤äº’]
é¢†åŸŸå±‚ (Domain)
    â†“ [ä»…é€šè¿‡Protocolè°ƒç”¨]
åŸºç¡€è®¾æ–½å±‚ (Infrastructure)
```

### 2.5 å¾ªç¯ä¾èµ–æ£€æµ‹

ä½¿ç”¨mypyä¸¥æ ¼æ¨¡å¼æ£€æµ‹å¾ªç¯ä¾èµ–ï¼š

```bash
# pyproject.tomlé…ç½®
[tool.mypy]
strict = true
disallow_any_unimported = true
no_implicit_reexport = true
warn_return_any = true

# è¿è¡Œæ£€æµ‹
mypy --strict backend/
```

---

## 3. åˆ†å±‚æ¶æ„ä¸æ¨¡å—åˆ’åˆ†ï¼ˆDDD é£æ ¼ï¼‰

### 3.1 é¢†åŸŸé©±åŠ¨è®¾è®¡åˆ†å±‚

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚        è¡¨ç°å±‚ (Presentation)            â”‚
â”‚   FastAPI Routers / Streamlit UI        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚         åº”ç”¨å±‚ (Application)            â”‚
â”‚   DiagnosisService / KnowledgeService   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚          é¢†åŸŸå±‚ (Domain)                â”‚
â”‚   å®ä½“ / å€¼å¯¹è±¡ / é¢†åŸŸæœåŠ¡ / èšåˆæ ¹      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚      åŸºç¡€è®¾æ–½å±‚ (Infrastructure)        â”‚
â”‚   VLM / Database / Cache / Storage      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 3.2 èšåˆæ ¹è®¾è®¡

**è¯Šæ–­èšåˆ (Diagnosis Aggregate)**ï¼š
```python
class DiagnosisAggregate:
    """è¯Šæ–­èšåˆæ ¹"""
    def __init__(self, diagnosis_id: str):
        self.diagnosis_id = diagnosis_id
        self.feature_vector: FeatureVector = None
        self.disease_matches: List[DiseaseMatch] = []
        self.final_diagnosis: DiagnosisResult = None
        self.images: List[ImageEntity] = []

    def add_image(self, image: ImageEntity) -> None:
        """æ·»åŠ è¯Šæ–­å›¾ç‰‡"""
        self.images.append(image)

    def extract_features(self, vlm_responses: dict) -> None:
        """æå–ç‰¹å¾å‘é‡"""
        self.feature_vector = FeatureVector.from_vlm_responses(vlm_responses)

    def match_diseases(self, candidates: List[DiseaseOntology]) -> None:
        """åŒ¹é…å€™é€‰ç–¾ç—…"""
        for disease in candidates:
            score = self._calculate_match_score(disease)
            self.disease_matches.append(DiseaseMatch(disease, score))

    def finalize_diagnosis(self) -> DiagnosisResult:
        """æœ€ç»ˆè¯Šæ–­å†³ç­–"""
        best_match = max(self.disease_matches, key=lambda x: x.score)
        confidence_level = self._determine_confidence_level(best_match.score)
        self.final_diagnosis = DiagnosisResult(
            disease=best_match.disease,
            confidence=best_match.score,
            level=confidence_level
        )
        return self.final_diagnosis
```

**çŸ¥è¯†åº“èšåˆ (KnowledgeBase Aggregate)**ï¼š
```python
class KnowledgeBaseAggregate:
    """çŸ¥è¯†åº“èšåˆæ ¹"""
    def __init__(self):
        self.diseases: Dict[str, DiseaseOntology] = {}
        self.plants: Dict[str, PlantOntology] = {}
        self.features: FeatureOntology = None
        self.host_disease_map: HostDiseaseMap = None
        self.version: str = None

    def load_from_json(self, base_path: str) -> None:
        """ä»JSONåŠ è½½çŸ¥è¯†åº“"""
        pass

    def get_diseases_by_genus(self, genus: str) -> List[DiseaseOntology]:
        """æ ¹æ®èŠ±å‰å±è·å–å€™é€‰ç–¾ç—…"""
        disease_ids = self.host_disease_map.get_diseases_for_host(genus)
        return [self.diseases[id] for id in disease_ids if id in self.diseases]

    def reload(self) -> None:
        """çƒ­æ›´æ–°çŸ¥è¯†åº“"""
        pass
```

### 3.3 å€¼å¯¹è±¡è®¾è®¡

```python
# å€¼å¯¹è±¡ï¼šä¸å¯å˜ï¼Œé€šè¿‡å€¼åˆ¤æ–­ç›¸ç­‰æ€§
@dataclass(frozen=True)
class FeatureVector:
    """ç‰¹å¾å‘é‡å€¼å¯¹è±¡"""
    content_type: str
    plant_category: str
    flower_genus: str
    organ: str
    completeness: str
    has_abnormality: str
    symptom_type: str
    color_center: Optional[str] = None
    location: Optional[str] = None
    size: Optional[str] = None
    distribution: Optional[str] = None

    def to_dict(self) -> dict:
        return asdict(self)

@dataclass(frozen=True)
class DiagnosisScore:
    """è¯Šæ–­åˆ†æ•°å€¼å¯¹è±¡"""
    total_score: float
    major_features_score: float
    minor_features_score: float
    optional_features_score: float

    @property
    def confidence_level(self) -> str:
        if self.total_score >= 0.85:
            return "confirmed"
        elif self.total_score >= 0.60:
            return "suspected"
        return "unlikely"
```

### 3.4 é¢†åŸŸæœåŠ¡

```python
class DomainDiagnosisService:
    """é¢†åŸŸå±‚è¯Šæ–­æœåŠ¡"""

    @staticmethod
    def calculate_weighted_score(
        feature_vector: FeatureVector,
        disease: DiseaseOntology
    ) -> DiagnosisScore:
        """è®¡ç®—åŠ æƒè¯Šæ–­åˆ†æ•°ï¼ˆæ ¸å¿ƒä¸šåŠ¡é€»è¾‘ï¼‰"""
        major_score = 0.0
        minor_score = 0.0
        optional_score = 0.0

        # Major Features (æƒé‡0.8)
        if feature_vector.symptom_type == disease.expected_symptom_type:
            major_score += 0.5
        if feature_vector.color_center in disease.expected_colors:
            major_score += 0.3

        # Minor Features (æƒé‡0.15)
        if feature_vector.location == disease.expected_location:
            minor_score += 0.1
        # ... å…¶ä»–æ¬¡è¦ç‰¹å¾

        # Optional Features (æƒé‡0.05)
        # ... å¯é€‰ç‰¹å¾è®¡ç®—

        total = major_score * 0.8 + minor_score * 0.15 + optional_score * 0.05

        return DiagnosisScore(
            total_score=total,
            major_features_score=major_score,
            minor_features_score=minor_score,
            optional_features_score=optional_score
        )
```

---

## 4. å®Œæ•´ç›®å½•ç»“æ„

```
PhytoOracle/
â”œâ”€â”€ backend/                                 # åç«¯æœåŠ¡ï¼ˆFastAPIï¼‰
â”‚   â”œâ”€â”€ apps/
â”‚   â”‚   â”œâ”€â”€ api/                            # FastAPI ä¸»åº”ç”¨
â”‚   â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”‚   â”œâ”€â”€ main.py                     # FastAPIåº”ç”¨å…¥å£ï¼Œé…ç½®CORSã€ä¸­é—´ä»¶
â”‚   â”‚   â”‚   â”œâ”€â”€ deps.py                     # ä¾èµ–æ³¨å…¥ï¼šDBè¿æ¥æ± ã€Redisã€VLM Client
â”‚   â”‚   â”‚   â”œâ”€â”€ routers/                    # è·¯ç”±æ¨¡å—
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ diagnosis.py            # POST /diagnose - è¯Šæ–­æ¥å£
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ knowledge.py            # GET /diseases, /plants - çŸ¥è¯†åº“æŸ¥è¯¢
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ admin.py                # POST /reload - çŸ¥è¯†åº“é‡è½½
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ auth.py                 # POST /login, /api-keys - è®¤è¯ç®¡ç†
â”‚   â”‚   â”‚   â”œâ”€â”€ schemas/                    # Pydanticè¯·æ±‚/å“åº”æ¨¡å‹
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ diagnosis.py            # DiagnosisRequest/Response
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ knowledge.py            # DiseaseSchema, PlantSchema
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ auth.py                 # LoginRequest, ApiKeyResponse
â”‚   â”‚   â”‚   â””â”€â”€ middleware/                 # ä¸­é—´ä»¶
â”‚   â”‚   â”‚       â”œâ”€â”€ __init__.py
â”‚   â”‚   â”‚       â””â”€â”€ auth.py                 # API KeyéªŒè¯ä¸­é—´ä»¶
â”‚   â”‚   â”‚
â”‚   â”‚   â””â”€â”€ admin/                          # ç®¡ç†åå°ï¼ˆStreamlitï¼‰
â”‚   â”‚       â”œâ”€â”€ __init__.py
â”‚   â”‚       â”œâ”€â”€ app.py                      # Streamlitä¸»å…¥å£
â”‚   â”‚       â”œâ”€â”€ pages/                      # å¤šé¡µé¢åº”ç”¨
â”‚   â”‚       â”‚   â”œâ”€â”€ 1_ğŸŒ¸_ç–¾ç—…ç®¡ç†.py        # ç–¾ç—…CRUDç•Œé¢
â”‚   â”‚       â”‚   â”œâ”€â”€ 2_ğŸ”¬_è¯Šæ–­æµ‹è¯•.py        # ä¸Šä¼ å›¾ç‰‡æµ‹è¯•è¯Šæ–­
â”‚   â”‚       â”‚   â”œâ”€â”€ 3_ğŸ“Š_ç»Ÿè®¡åˆ†æ.py        # å‡†ç¡®ç‡ç»Ÿè®¡
â”‚   â”‚       â”‚   â””â”€â”€ 4_ğŸ”„_çŸ¥è¯†åº“ç‰ˆæœ¬.py      # ç‰ˆæœ¬ç®¡ç†ä¸å›æ»š
â”‚   â”‚       â””â”€â”€ utils/                      # å·¥å…·å‡½æ•°
â”‚   â”‚           â””â”€â”€ auth.py                 # Streamlitè®¤è¯
â”‚   â”‚
â”‚   â”œâ”€â”€ core/                               # æ ¸å¿ƒé…ç½®ä¸å·¥å…·
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”œâ”€â”€ config.py                       # Settingsç±»ï¼Œä».envåŠ è½½é…ç½®
â”‚   â”‚   â”œâ”€â”€ security.py                     # API Keyç”Ÿæˆ(secrets)ã€å¯†ç å“ˆå¸Œ(bcrypt)
â”‚   â”‚   â”œâ”€â”€ exceptions.py                   # è‡ªå®šä¹‰å¼‚å¸¸ï¼šDiagnosisError, VLMError
â”‚   â”‚   â””â”€â”€ cache.py                        # Redisç¼“å­˜å°è£…ç±»
â”‚   â”‚
â”‚   â”œâ”€â”€ domain/                             # DDDé¢†åŸŸæ¨¡å‹ï¼ˆPydantic V2ï¼‰
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”œâ”€â”€ diagnosis.py                    # DiagnosisAggregate, DiagnosisResult
â”‚   â”‚   â”œâ”€â”€ disease.py                      # DiseaseOntologyé¢†åŸŸæ¨¡å‹
â”‚   â”‚   â”œâ”€â”€ feature.py                      # FeatureOntology, FeatureVector
â”‚   â”‚   â”œâ”€â”€ plant.py                        # PlantOntologyé¢†åŸŸæ¨¡å‹
â”‚   â”‚   â”œâ”€â”€ treatment.py                    # TreatmentOntologyï¼ˆv1.3é¢„ç•™ï¼‰
â”‚   â”‚   â””â”€â”€ value_objects.py                # å€¼å¯¹è±¡ï¼šScore, Confidence
â”‚   â”‚
â”‚   â”œâ”€â”€ infrastructure/                     # åŸºç¡€è®¾æ–½å±‚
â”‚   â”‚   â”œâ”€â”€ llm/
â”‚   â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”‚   â”œâ”€â”€ base.py                     # VLMProtocolæŠ½è±¡æ¥å£
â”‚   â”‚   â”‚   â”œâ”€â”€ client.py                   # VLMClientå®ç°Fallbackæœºåˆ¶
â”‚   â”‚   â”‚   â”œâ”€â”€ providers/                  # å…·ä½“Providerå®ç°
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ qwen.py                 # QwenVLPlusProvider
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ chatgpt.py              # ChatGPTProvider (gpt-4o)
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ grok.py                 # GrokVisionProvider
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ claude.py               # ClaudeProvider
â”‚   â”‚   â”‚   â””â”€â”€ prompts.py                  # Q0-Q6é—®é¢˜æ¨¡æ¿å®šä¹‰
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ ontology/
â”‚   â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”‚   â”œâ”€â”€ loader.py                   # JSONKnowledgeLoader - åŠ è½½JSONçŸ¥è¯†åº“
â”‚   â”‚   â”‚   â”œâ”€â”€ matcher.py                  # FuzzyMatcher - æ¨¡ç³ŠåŒ¹é…COLOR_GROUPS/SIZE_ORDER
â”‚   â”‚   â”‚   â””â”€â”€ scorer.py                   # DiagnosisScorer - åŠ æƒè¯„åˆ†0.8/0.15/0.05
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ persistence/
â”‚   â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”‚   â”œâ”€â”€ database.py                 # create_pool() - asyncpgè¿æ¥æ± 
â”‚   â”‚   â”‚   â”œâ”€â”€ redis_client.py             # RedisCacheç±»å°è£…
â”‚   â”‚   â”‚   â””â”€â”€ repositories/               # æ•°æ®è®¿é—®å±‚
â”‚   â”‚   â”‚       â”œâ”€â”€ __init__.py
â”‚   â”‚   â”‚       â”œâ”€â”€ diagnosis_repo.py       # è¯Šæ–­è®°å½•CRUD (asyncpg)
â”‚   â”‚   â”‚       â”œâ”€â”€ image_repo.py           # å›¾ç‰‡å…ƒæ•°æ®CRUD
â”‚   â”‚   â”‚       â””â”€â”€ apikey_repo.py          # API Keyç®¡ç†
â”‚   â”‚   â”‚
â”‚   â”‚   â””â”€â”€ storage/
â”‚   â”‚       â”œâ”€â”€ __init__.py
â”‚   â”‚       â””â”€â”€ local_storage.py            # LocalImageStorage - æŒ‰åˆ†ç±»å­˜å‚¨å›¾ç‰‡
â”‚   â”‚
â”‚   â”œâ”€â”€ services/                           # ä¸šåŠ¡é€»è¾‘å±‚ï¼ˆåº”ç”¨æœåŠ¡ï¼‰
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”œâ”€â”€ diagnosis_service.py            # æ ¸å¿ƒè¯Šæ–­æµç¨‹ç¼–æ’
â”‚   â”‚   â”œâ”€â”€ knowledge_service.py            # çŸ¥è¯†åº“åŠ è½½ã€é‡è½½ã€æŸ¥è¯¢
â”‚   â”‚   â””â”€â”€ image_service.py                # å›¾ç‰‡ä¿å­˜ã€åˆ†ç±»ã€å…ƒæ•°æ®ç®¡ç†
â”‚   â”‚
â”‚   â”œâ”€â”€ tests/                              # æµ‹è¯•ç›®å½•
â”‚   â”‚   â”œâ”€â”€ conftest.py                     # Pytest fixtures
â”‚   â”‚   â”œâ”€â”€ unit/                           # å•å…ƒæµ‹è¯•
â”‚   â”‚   â”‚   â”œâ”€â”€ test_matcher.py             # æµ‹è¯•COLOR_GROUPSæ¨¡ç³ŠåŒ¹é…
â”‚   â”‚   â”‚   â”œâ”€â”€ test_scorer.py              # æµ‹è¯•åŠ æƒè¯„åˆ†ç®—æ³•
â”‚   â”‚   â”‚   â””â”€â”€ test_vlm_client.py          # æµ‹è¯•VLM Fallbackæœºåˆ¶
â”‚   â”‚   â”œâ”€â”€ integration/                    # é›†æˆæµ‹è¯•
â”‚   â”‚   â”‚   â”œâ”€â”€ test_diagnosis_api.py       # æµ‹è¯•å®Œæ•´è¯Šæ–­APIæµç¨‹
â”‚   â”‚   â”‚   â””â”€â”€ test_knowledge_reload.py    # æµ‹è¯•çŸ¥è¯†åº“çƒ­æ›´æ–°
â”‚   â”‚   â””â”€â”€ e2e/                            # ç«¯åˆ°ç«¯æµ‹è¯•ï¼ˆPlaywrightï¼‰
â”‚   â”‚       â””â”€â”€ test_diagnosis_flow.py      # æµ‹è¯•Webç•Œé¢å®Œæ•´æµç¨‹
â”‚   â”‚
â”‚   â”œâ”€â”€ knowledge_base/                     # çŸ¥è¯†åº“JSONæ–‡ä»¶ï¼ˆGitç‰ˆæœ¬æ§åˆ¶ï¼‰
â”‚   â”‚   â”œâ”€â”€ diseases/                       # ç–¾ç—…æœ¬ä½“JSON
â”‚   â”‚   â”‚   â”œâ”€â”€ rose_black_spot.json        # ç«ç‘°é»‘æ–‘ç—…
â”‚   â”‚   â”‚   â”œâ”€â”€ cherry_powdery_mildew.json  # æ¨±èŠ±ç™½ç²‰ç—…
â”‚   â”‚   â”‚   â””â”€â”€ ...                         # å…¶ä»–18-24ç§ç–¾ç—…
â”‚   â”‚   â”œâ”€â”€ features/                       # ç‰¹å¾æœ¬ä½“
â”‚   â”‚   â”‚   â””â”€â”€ feature_ontology.json       # ç‰¹å¾å®šä¹‰ä¸æ¨¡ç³ŠåŒ¹é…è§„åˆ™
â”‚   â”‚   â”œâ”€â”€ plants/                         # æ¤ç‰©æœ¬ä½“
â”‚   â”‚   â”‚   â”œâ”€â”€ rosa.json                   # ç«ç‘°å±
â”‚   â”‚   â”‚   â”œâ”€â”€ prunus.json                 # æ¨±èŠ±å±
â”‚   â”‚   â”‚   â”œâ”€â”€ tulipa.json                 # éƒé‡‘é¦™å±
â”‚   â”‚   â”‚   â”œâ”€â”€ dianthus.json               # åº·ä¹ƒé¦¨å±
â”‚   â”‚   â”‚   â””â”€â”€ paeonia.json                # ç‰¡ä¸¹å±
â”‚   â”‚   â”œâ”€â”€ host_disease/                   # å®¿ä¸»-ç–¾ç—…å…³ç³»
â”‚   â”‚   â”‚   â””â”€â”€ associations.json           # èŠ±å‰ä¸ç–¾ç—…æ˜ å°„å…³ç³»
â”‚   â”‚   â””â”€â”€ treatments/                     # æ²»ç–—æ–¹æ¡ˆï¼ˆv1.3+é¢„ç•™ï¼‰
â”‚   â”‚
â”‚   â”œâ”€â”€ storage/                            # æœ¬åœ°æ–‡ä»¶å­˜å‚¨ç›®å½•
â”‚   â”‚   â”œâ”€â”€ images/
â”‚   â”‚   â”‚   â”œâ”€â”€ unlabeled/                  # æœªæ ‡æ³¨å›¾ç‰‡
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ rose/
â”‚   â”‚   â”‚   â”‚   â”‚   â””â”€â”€ 2025-01/
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ cherry/
â”‚   â”‚   â”‚   â”œâ”€â”€ correct/                    # è¯Šæ–­æ­£ç¡®
â”‚   â”‚   â”‚   â””â”€â”€ incorrect/                  # è¯Šæ–­é”™è¯¯
â”‚   â”‚   â””â”€â”€ metadata/                       # å›¾ç‰‡å…ƒæ•°æ®JSONç¼“å­˜
â”‚   â”‚
â”‚   â”œâ”€â”€ scripts/                            # è¿ç»´è„šæœ¬
â”‚   â”‚   â”œâ”€â”€ init_db.sql                     # åˆ›å»ºè¡¨ç»“æ„SQLè„šæœ¬
â”‚   â”‚   â”œâ”€â”€ seed_apikeys.py                 # ç”Ÿæˆæµ‹è¯•ç”¨API Key
â”‚   â”‚   â””â”€â”€ validate_ontology.py            # JSON Schemaæ ¡éªŒè„šæœ¬
â”‚   â”‚
â”‚   â”œâ”€â”€ pyproject.toml                      # Poetryä¾èµ–ç®¡ç†
â”‚   â”œâ”€â”€ .env.example                        # ç¯å¢ƒå˜é‡æ¨¡æ¿
â”‚   â”œâ”€â”€ .gitignore
â”‚   â””â”€â”€ README.md                           # åç«¯éƒ¨ç½²è¯´æ˜
â”‚
â”œâ”€â”€ frontend/                               # å‰ç«¯ï¼ˆNext.js 15ï¼‰
â”‚   â”œâ”€â”€ app/                                # App Router
â”‚   â”‚   â”œâ”€â”€ layout.tsx                      # æ ¹å¸ƒå±€
â”‚   â”‚   â”œâ”€â”€ page.tsx                        # é¦–é¡µ
â”‚   â”‚   â”œâ”€â”€ diagnose/
â”‚   â”‚   â”‚   â””â”€â”€ page.tsx                    # è¯Šæ–­é¡µé¢
â”‚   â”‚   â”œâ”€â”€ history/
â”‚   â”‚   â”‚   â””â”€â”€ page.tsx                    # å†å²è®°å½•é¡µé¢
â”‚   â”‚   â”œâ”€â”€ login/
â”‚   â”‚   â”‚   â””â”€â”€ page.tsx                    # ç™»å½•é¡µé¢
â”‚   â”‚   â””â”€â”€ api/
â”‚   â”‚       â””â”€â”€ [...].ts                    # APIä»£ç†ï¼ˆå¯é€‰ï¼‰
â”‚   â”œâ”€â”€ components/                         # Reactç»„ä»¶
â”‚   â”‚   â”œâ”€â”€ ui/                             # Shadcn UIç»„ä»¶
â”‚   â”‚   â”œâ”€â”€ ImageUploader.tsx               # å›¾ç‰‡ä¸Šä¼ ç»„ä»¶
â”‚   â”‚   â”œâ”€â”€ DiagnosisResult.tsx             # è¯Šæ–­ç»“æœå±•ç¤º
â”‚   â”‚   â””â”€â”€ FeatureDisplay.tsx              # ç‰¹å¾å‘é‡å¯è§†åŒ–
â”‚   â”œâ”€â”€ lib/                                # å·¥å…·åº“
â”‚   â”‚   â”œâ”€â”€ api.ts                          # APIè°ƒç”¨å°è£…
â”‚   â”‚   â””â”€â”€ utils.ts                        # å·¥å…·å‡½æ•°
â”‚   â”œâ”€â”€ public/                             # é™æ€èµ„æº
â”‚   â”œâ”€â”€ package.json
â”‚   â”œâ”€â”€ next.config.js
â”‚   â”œâ”€â”€ tailwind.config.js
â”‚   â””â”€â”€ tsconfig.json
â”‚
â””â”€â”€ docs/                                   # é¡¹ç›®æ–‡æ¡£
    â”œâ”€â”€ requirements/                       # éœ€æ±‚æ–‡æ¡£
    â”‚   â””â”€â”€ éœ€æ±‚æ–‡æ¡£.md
    â”œâ”€â”€ design/                             # è¯¦ç»†è®¾è®¡æ–‡æ¡£
    â”‚   â””â”€â”€ è¯¦ç»†è®¾è®¡æ–‡æ¡£.md                  # æœ¬æ–‡æ¡£
    â”œâ”€â”€ methodology/                        # æ–¹æ³•è®ºæ–‡æ¡£
    â”‚   â””â”€â”€ æ–¹æ³•è®ºv4.0å®Œæ•´æ–‡æ¡£.md
    â””â”€â”€ api/                                # APIæ–‡æ¡£
        â””â”€â”€ openapi.yaml                    # OpenAPI 3.0è§„èŒƒ
```

---

## 5. æ ¸å¿ƒæœåŠ¡ä¸æ¨¡å—è¯¦ç»†è®¾è®¡

### 5.1 è¯Šæ–­æœåŠ¡ (DiagnosisService)

```python
# services/diagnosis_service.py
class DiagnosisService:
    """æ ¸å¿ƒè¯Šæ–­æœåŠ¡ - ç¼–æ’è¯Šæ–­æµç¨‹"""

    def __init__(
        self,
        vlm_client: VLMClient,
        knowledge_base: KnowledgeBaseAggregate,
        scorer: DiagnosisScorer,
        diagnosis_repo: DiagnosisRepository,
        image_service: ImageService,
        cache: RedisCache
    ):
        self.vlm_client = vlm_client
        self.knowledge_base = knowledge_base
        self.scorer = scorer
        self.diagnosis_repo = diagnosis_repo
        self.image_service = image_service
        self.cache = cache

    async def diagnose(self, image_bytes: bytes, metadata: dict = None) -> DiagnosisResult:
        """æ‰§è¡Œå®Œæ•´è¯Šæ–­æµç¨‹"""
        # 1. åˆ›å»ºè¯Šæ–­èšåˆ
        diagnosis = DiagnosisAggregate(
            diagnosis_id=generate_diagnosis_id()
        )

        # 2. ä¿å­˜å›¾ç‰‡
        image_path = await self.image_service.save_image(
            image_bytes,
            diagnosis.diagnosis_id
        )

        # 3. Q0é€çº§è¿‡æ»¤
        q0_responses = await self._execute_q0_sequence(image_bytes)

        # æ£€æŸ¥Q0.0: æ˜¯å¦æ¤ç‰©
        if q0_responses["content_type"] != "plant":
            return DiagnosisResult(
                error="ä¸æ”¯æŒçš„å›¾ç‰‡ç±»å‹ï¼Œè¯·ä¸Šä¼ æ¤ç‰©å›¾ç‰‡"
            )

        # æ£€æŸ¥Q0.1: æ˜¯å¦èŠ±å‰
        if q0_responses["plant_category"] != "flower":
            return DiagnosisResult(
                error="å½“å‰ä»…æ”¯æŒèŠ±å‰ç–¾ç—…è¯Šæ–­"
            )

        # Q0.2: è·å–èŠ±å‰ç§å±
        flower_genus = q0_responses["flower_genus"]

        # æ£€æŸ¥Q0.5: æ˜¯å¦æœ‰å¼‚å¸¸
        if q0_responses["has_abnormality"] == "healthy":
            return DiagnosisResult(
                disease_name="å¥åº·",
                confidence=1.0,
                level="confirmed"
            )

        # 4. Q1-Q6åŠ¨æ€ç‰¹å¾æå–
        q1_q6_responses = await self._execute_q1_q6_sequence(
            image_bytes,
            q0_responses["symptom_type"]
        )

        # 5. æ„å»ºç‰¹å¾å‘é‡
        feature_vector = FeatureVector(
            **q0_responses,
            **q1_q6_responses
        )
        diagnosis.extract_features(feature_vector)

        # 6. è·å–å€™é€‰ç–¾ç—…ï¼ˆåŸºäºç§å±ï¼‰
        candidate_diseases = self.knowledge_base.get_diseases_by_genus(flower_genus)

        # 7. ç–¾ç—…åŒ¹é…ä¸è¯„åˆ†
        disease_scores = []
        for disease in candidate_diseases:
            score = self.scorer.calculate_score(
                feature_vector.to_dict(),
                disease.to_dict()
            )
            disease_scores.append((disease, score))

        # 8. æ’åºå¹¶ç¡®å®šè¯Šæ–­ç»“æœ
        disease_scores.sort(key=lambda x: x[1].total_score, reverse=True)

        # 9. æ ¹æ®ç½®ä¿¡åº¦åˆ†å±‚å†³ç­–
        best_match = disease_scores[0] if disease_scores else None

        if not best_match or best_match[1].total_score < 0.60:
            # Low Confidence: VLMå…œåº•
            return await self._vlm_fallback_diagnosis(image_bytes)

        elif best_match[1].total_score < 0.85:
            # Medium Confidence: è¿”å›ç–‘ä¼¼è¯Šæ–­
            top_candidates = disease_scores[:3]
            return DiagnosisResult(
                disease_id=best_match[0].disease_id,
                disease_name=best_match[0].disease_name,
                confidence=best_match[1].total_score,
                level="suspected",
                candidates=[
                    {
                        "disease_name": d[0].disease_name,
                        "confidence": d[1].total_score
                    }
                    for d in top_candidates
                ]
            )
        else:
            # High Confidence: ç¡®è¯Š
            return DiagnosisResult(
                disease_id=best_match[0].disease_id,
                disease_name=best_match[0].disease_name,
                confidence=best_match[1].total_score,
                level="confirmed"
            )

    async def _execute_q0_sequence(self, image_bytes: bytes) -> dict:
        """æ‰§è¡ŒQ0é€çº§è¿‡æ»¤"""
        # å®ç°Q0.0-Q0.5çš„VLMè°ƒç”¨
        pass

    async def _execute_q1_q6_sequence(self, image_bytes: bytes, symptom_type: str) -> dict:
        """æ‰§è¡ŒQ1-Q6åŠ¨æ€ç‰¹å¾æå–"""
        # æ ¹æ®symptom_typeåŠ¨æ€ç”Ÿæˆé—®é¢˜
        pass
```

### 5.2 VLMå®¢æˆ·ç«¯ (VLMClient)

```python
# infrastructure/llm/client.py
class VLMClient:
    """VLMå®¢æˆ·ç«¯ - å®ç°Fallbackæœºåˆ¶"""

    def __init__(self, providers: List[VLMProvider], cache: RedisCache):
        self.providers = providers  # æŒ‰ä¼˜å…ˆçº§æ’åº
        self.cache = cache
        self.current_provider_index = 0

    async def call_with_fallback(
        self,
        prompt: str,
        image_bytes: bytes,
        question_id: str = None
    ) -> str:
        """å¸¦é™çº§çš„VLMè°ƒç”¨"""
        # 1. å°è¯•ç¼“å­˜
        if question_id:
            cache_key = self._build_cache_key(image_bytes, question_id)
            cached = await self.cache.get(cache_key)
            if cached:
                return cached

        # 2. ä¾æ¬¡å°è¯•å„Provider
        last_error = None
        for i, provider in enumerate(self.providers):
            try:
                # è®¾ç½®è¶…æ—¶30ç§’
                result = await asyncio.wait_for(
                    provider.call(prompt, image_bytes),
                    timeout=30.0
                )

                # ç¼“å­˜ç»“æœ
                if question_id:
                    await self.cache.set(cache_key, result, ttl=7*24*3600)

                return result

            except asyncio.TimeoutError:
                logger.warning(f"Provider {provider.__class__.__name__} timeout")
                last_error = "VLMè°ƒç”¨è¶…æ—¶"
                continue

            except Exception as e:
                logger.error(f"Provider {provider.__class__.__name__} failed: {e}")
                last_error = str(e)
                continue

        # 3. æ‰€æœ‰Provideréƒ½å¤±è´¥
        raise VLMError(f"All VLM providers failed. Last error: {last_error}")

    def _build_cache_key(self, image_bytes: bytes, question_id: str) -> str:
        """æ„å»ºç¼“å­˜é”®"""
        image_hash = hashlib.md5(image_bytes).hexdigest()
        provider_name = self.providers[0].__class__.__name__
        return f"vlm:{provider_name}:{image_hash}:{question_id}"
```

### 5.3 æ¨¡ç³ŠåŒ¹é…å¼•æ“ (FuzzyMatcher)

```python
# infrastructure/ontology/matcher.py
class FuzzyMatcher:
    """æ¨¡ç³ŠåŒ¹é…å¼•æ“ - å¤„ç†VLMè§‚å¯Ÿè¯¯å·®"""

    # é¢œè‰²åˆ†ç»„å®šä¹‰
    COLOR_GROUPS = {
        "é»‘è¤è‰²ç³»": ["black", "dark_brown", "brown", "dark"],
        "é»„è‰²ç³»": ["yellow", "light_yellow", "yellowish_green", "pale_yellow"],
        "ç™½è‰²ç³»": ["white", "gray_white", "off_white", "cream"],
        "çº¢è‰²ç³»": ["red", "dark_red", "reddish_brown", "crimson"],
        "ç»¿è‰²ç³»": ["green", "light_green", "dark_green", "yellowish_green"]
    }

    # å°ºå¯¸é¡ºåºå®šä¹‰
    SIZE_ORDER = ["pinpoint", "small", "medium_small", "medium", "large"]

    def match_color(self, observed: str, expected: Union[str, List[str]]) -> bool:
        """é¢œè‰²æ¨¡ç³ŠåŒ¹é…"""
        if isinstance(expected, str):
            expected = [expected]

        for exp_color in expected:
            # 1. ç²¾ç¡®åŒ¹é…
            if observed == exp_color:
                return True

            # 2. åŒè‰²ç³»åŒ¹é…
            for group_name, group_colors in self.COLOR_GROUPS.items():
                if observed in group_colors and exp_color in group_colors:
                    return True

        return False

    def match_size(self, observed: str, expected: str) -> bool:
        """å°ºå¯¸æ¨¡ç³ŠåŒ¹é… - å…è®¸Â±1çº§åˆ«è¯¯å·®"""
        try:
            obs_idx = self.SIZE_ORDER.index(observed)
            exp_idx = self.SIZE_ORDER.index(expected)
            return abs(obs_idx - exp_idx) <= 1
        except ValueError:
            # æœªçŸ¥å°ºå¯¸ï¼Œè¿”å›False
            return False

    def match_location(self, observed: str, expected: Union[str, List[str]]) -> bool:
        """ä½ç½®åŒ¹é… - æ”¯æŒå¤šå€¼"""
        if isinstance(expected, str):
            expected = [expected]
        return observed in expected
```

### 5.4 åŠ æƒè¯Šæ–­è¯„åˆ†å™¨ (DiagnosisScorer)

```python
# infrastructure/ontology/scorer.py
class DiagnosisScorer:
    """åŠ æƒè¯Šæ–­è¯„åˆ†å™¨ - æ ¸å¿ƒè¯Šæ–­ç®—æ³•"""

    def __init__(self, matcher: FuzzyMatcher):
        self.matcher = matcher

    def calculate_score(
        self,
        observed_features: dict,
        disease_definition: dict
    ) -> DiagnosisScore:
        """è®¡ç®—è¯Šæ–­åˆ†æ•°"""

        # è·å–ç‰¹å¾é‡è¦æ€§é…ç½®
        importance = disease_definition.get("feature_importance", {})
        major_features = importance.get("major_features", {})
        minor_features = importance.get("minor_features", {})
        optional_features = importance.get("optional_features", {})

        # è®¡ç®—å„ç±»ç‰¹å¾å¾—åˆ†
        major_score = self._calculate_major_score(
            observed_features,
            major_features
        )
        minor_score = self._calculate_minor_score(
            observed_features,
            minor_features
        )
        optional_score = self._calculate_optional_score(
            observed_features,
            optional_features
        )

        # åº”ç”¨å®Œæ•´æ€§ä¿®æ­£
        completeness = observed_features.get("completeness", "complete")
        modifier = {
            "complete": 1.0,
            "partial": 0.8,
            "close_up": 0.6
        }.get(completeness, 1.0)

        # è®¡ç®—æ€»åˆ†
        total_score = (
            major_score * 0.8 +
            minor_score * 0.15 +
            optional_score * 0.05
        ) * modifier

        return DiagnosisScore(
            total_score=min(total_score, 1.0),
            major_features_score=major_score,
            minor_features_score=minor_score,
            optional_features_score=optional_score
        )

    def _calculate_major_score(self, observed: dict, major_config: dict) -> float:
        """è®¡ç®—ä¸»è¦ç‰¹å¾å¾—åˆ†"""
        score = 0.0
        features = major_config.get("features", [])

        for feature in features:
            dimension = feature["dimension"]
            expected = feature["expected_values"]
            weight = feature["weight"]

            if dimension == "symptom_type":
                if observed.get("symptom_type") in expected:
                    score += weight

            elif dimension == "color_center":
                if self.matcher.match_color(
                    observed.get("color_center", ""),
                    expected
                ):
                    score += weight

        return score
```

### 5.5 çŸ¥è¯†åº“åŠ è½½å™¨ (KnowledgeLoader)

```python
# infrastructure/ontology/loader.py
class JSONKnowledgeLoader:
    """JSONçŸ¥è¯†åº“åŠ è½½å™¨"""

    def __init__(self, base_path: str):
        self.base_path = Path(base_path)
        self._cache = {}

    async def load_all(self) -> KnowledgeBaseAggregate:
        """åŠ è½½å®Œæ•´çŸ¥è¯†åº“"""
        kb = KnowledgeBaseAggregate()

        # åŠ è½½ç–¾ç—…æœ¬ä½“
        diseases_path = self.base_path / "diseases"
        for disease_file in diseases_path.glob("*.json"):
            with open(disease_file, 'r', encoding='utf-8') as f:
                data = json.load(f)
                disease = DiseaseOntology(**data)
                kb.diseases[disease.disease_id] = disease

        # åŠ è½½æ¤ç‰©æœ¬ä½“
        plants_path = self.base_path / "plants"
        for plant_file in plants_path.glob("*.json"):
            with open(plant_file, 'r', encoding='utf-8') as f:
                data = json.load(f)
                plant = PlantOntology(**data)
                kb.plants[plant.genus] = plant

        # åŠ è½½ç‰¹å¾æœ¬ä½“
        features_file = self.base_path / "features" / "feature_ontology.json"
        with open(features_file, 'r', encoding='utf-8') as f:
            data = json.load(f)
            kb.features = FeatureOntology(**data)

        # åŠ è½½å®¿ä¸»-ç–¾ç—…å…³ç³»
        host_disease_file = self.base_path / "host_disease" / "associations.json"
        with open(host_disease_file, 'r', encoding='utf-8') as f:
            data = json.load(f)
            kb.host_disease_map = HostDiseaseMap(**data)

        # è®°å½•ç‰ˆæœ¬
        kb.version = self._get_git_commit_hash()

        return kb

    async def reload(self) -> KnowledgeBaseAggregate:
        """çƒ­æ›´æ–°çŸ¥è¯†åº“"""
        # æ¸…é™¤ç¼“å­˜
        self._cache.clear()
        # é‡æ–°åŠ è½½
        return await self.load_all()
```

---

## 6. API è®¾è®¡ï¼ˆOpenAPI è§„èŒƒç‰‡æ®µï¼‰

```yaml
openapi: 3.0.3
info:
  title: PhytoOracle API
  version: 1.0.0
  description: èŠ±å‰ç–¾ç—…è¯Šæ–­ç³»ç»ŸAPI

servers:
  - url: http://localhost:8000/api/v1
    description: å¼€å‘ç¯å¢ƒ
  - url: https://api.phytooracle.com/api/v1
    description: ç”Ÿäº§ç¯å¢ƒ

paths:
  /diagnose:
    post:
      summary: æ‰§è¡Œç–¾ç—…è¯Šæ–­
      operationId: diagnose
      tags: [Diagnosis]
      security:
        - ApiKeyAuth: []
      requestBody:
        content:
          multipart/form-data:
            schema:
              type: object
              required: [image]
              properties:
                image:
                  type: string
                  format: binary
                  description: å›¾ç‰‡æ–‡ä»¶(JPG/PNG/HEIC)
                flower_genus:
                  type: string
                  description: èŠ±å‰ç§å±(å¯é€‰ï¼Œæé«˜å‡†ç¡®ç‡)
                  enum: [Rosa, Prunus, Tulipa, Dianthus, Paeonia]
      responses:
        '200':
          description: è¯Šæ–­æˆåŠŸ
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/DiagnosisResponse'
        '400':
          description: è¯·æ±‚é”™è¯¯
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/ErrorResponse'
        '401':
          description: æœªæˆæƒ
        '500':
          description: æœåŠ¡å™¨é”™è¯¯

  /diseases:
    get:
      summary: è·å–ç–¾ç—…åˆ—è¡¨
      operationId: listDiseases
      tags: [Knowledge]
      parameters:
        - name: genus
          in: query
          schema:
            type: string
          description: æŒ‰èŠ±å‰å±è¿‡æ»¤
      responses:
        '200':
          description: æˆåŠŸ
          content:
            application/json:
              schema:
                type: array
                items:
                  $ref: '#/components/schemas/Disease'

  /admin/reload:
    post:
      summary: é‡è½½çŸ¥è¯†åº“
      operationId: reloadKnowledge
      tags: [Admin]
      security:
        - ApiKeyAuth: []
      responses:
        '200':
          description: é‡è½½æˆåŠŸ
          content:
            application/json:
              schema:
                type: object
                properties:
                  message:
                    type: string
                  version:
                    type: string
                  disease_count:
                    type: integer

  /auth/login:
    post:
      summary: ç®¡ç†å‘˜ç™»å½•
      operationId: login
      tags: [Auth]
      requestBody:
        content:
          application/json:
            schema:
              type: object
              required: [username, password]
              properties:
                username:
                  type: string
                password:
                  type: string
      responses:
        '200':
          description: ç™»å½•æˆåŠŸ
          content:
            application/json:
              schema:
                type: object
                properties:
                  access_token:
                    type: string
                  token_type:
                    type: string
                    default: bearer

  /history:
    get:
      summary: æŸ¥è¯¢è¯Šæ–­å†å²
      operationId: getDiagnosisHistory
      tags: [Diagnosis]
      security:
        - ApiKeyAuth: []
      parameters:
        - name: start_date
          in: query
          schema:
            type: string
            format: date
        - name: end_date
          in: query
          schema:
            type: string
            format: date
        - name: plant_genus
          in: query
          schema:
            type: string
        - name: confidence_level
          in: query
          schema:
            type: string
            enum: [confirmed, suspected, unlikely]
      responses:
        '200':
          description: æˆåŠŸ
          content:
            application/json:
              schema:
                type: array
                items:
                  $ref: '#/components/schemas/DiagnosisHistory'

components:
  securitySchemes:
    ApiKeyAuth:
      type: apiKey
      in: header
      name: X-API-Key

  schemas:
    DiagnosisResponse:
      type: object
      properties:
        diagnosis_id:
          type: string
          example: diag_20250111_001
        timestamp:
          type: string
          format: date-time
        diagnosis:
          type: object
          properties:
            disease_id:
              type: string
            disease_name:
              type: string
            common_name_en:
              type: string
            pathogen:
              type: string
            level:
              type: string
              enum: [confirmed, suspected, unlikely]
            confidence:
              type: number
              format: float
              minimum: 0
              maximum: 1
        feature_vector:
          $ref: '#/components/schemas/FeatureVector'
        scores:
          type: object
          properties:
            total_score:
              type: number
            major_features:
              type: object
            minor_features:
              type: object
            optional_features:
              type: object
        reasoning:
          type: array
          items:
            type: string
        candidates:
          type: array
          description: ç–‘ä¼¼è¯Šæ–­æ—¶çš„å€™é€‰ç–¾ç—…
          items:
            type: object
            properties:
              disease_name:
                type: string
              confidence:
                type: number
        vlm_provider:
          type: string
        execution_time_ms:
          type: integer

    FeatureVector:
      type: object
      properties:
        content_type:
          type: string
        plant_category:
          type: string
        flower_genus:
          type: string
        organ:
          type: string
        completeness:
          type: string
        has_abnormality:
          type: string
        symptom_type:
          type: string
        color_center:
          type: string
        location:
          type: string
        size:
          type: string
        distribution:
          type: string

    Disease:
      type: object
      properties:
        disease_id:
          type: string
        disease_name:
          type: string
        common_name_en:
          type: string
        pathogen:
          type: string
        affected_plants:
          type: array
          items:
            type: string
        typical_symptoms:
          type: array
          items:
            type: string

    ErrorResponse:
      type: object
      properties:
        error:
          type: string
        detail:
          type: string
        timestamp:
          type: string
          format: date-time
```

---

## 7. æ•°æ®æ¨¡å‹ï¼ˆPydantic V2 å®Œæ•´ä»£ç ï¼‰

```python
# domain/diagnosis.py
from pydantic import BaseModel, Field, ConfigDict
from typing import Optional, List, Dict, Any
from datetime import datetime
from enum import Enum

class ContentType(str, Enum):
    """å›¾ç‰‡å†…å®¹ç±»å‹"""
    PLANT = "plant"
    ANIMAL = "animal"
    PERSON = "person"
    OBJECT = "object"
    LANDSCAPE = "landscape"
    OTHER = "other"

class PlantCategory(str, Enum):
    """æ¤ç‰©ç±»åˆ«"""
    FLOWER = "flower"
    VEGETABLE = "vegetable"
    TREE = "tree"
    CROP = "crop"
    GRASS = "grass"
    OTHER = "other"

class FlowerGenus(str, Enum):
    """èŠ±å‰ç§å±"""
    ROSA = "Rosa"
    PRUNUS = "Prunus"
    TULIPA = "Tulipa"
    DIANTHUS = "Dianthus"
    PAEONIA = "Paeonia"
    OTHER = "Other"

class OrganType(str, Enum):
    """å™¨å®˜ç±»å‹"""
    FLOWER = "flower"
    LEAF = "leaf"

class Completeness(str, Enum):
    """å®Œæ•´æ€§"""
    COMPLETE = "complete"
    PARTIAL = "partial"
    CLOSE_UP = "close_up"

class AbnormalityStatus(str, Enum):
    """å¼‚å¸¸çŠ¶æ€"""
    HEALTHY = "healthy"
    ABNORMAL = "abnormal"

class ConfidenceLevel(str, Enum):
    """ç½®ä¿¡åº¦çº§åˆ«"""
    CONFIRMED = "confirmed"
    SUSPECTED = "suspected"
    UNLIKELY = "unlikely"

class FeatureVector(BaseModel):
    """ç‰¹å¾å‘é‡æ¨¡å‹"""
    model_config = ConfigDict(use_enum_values=True)

    # Q0ç‰¹å¾
    content_type: ContentType
    plant_category: PlantCategory
    flower_genus: FlowerGenus
    organ: OrganType
    completeness: Completeness
    has_abnormality: AbnormalityStatus

    # Q1-Q6ç‰¹å¾
    symptom_type: Optional[str] = None
    color_center: Optional[str] = None
    color_border: Optional[str] = None
    location: Optional[str] = None
    size: Optional[str] = None
    distribution: Optional[str] = None
    additional_features: Dict[str, Any] = Field(default_factory=dict)

class DiagnosisScore(BaseModel):
    """è¯Šæ–­åˆ†æ•°æ¨¡å‹"""
    model_config = ConfigDict(frozen=True)

    total_score: float = Field(..., ge=0, le=1)
    major_features_score: float = Field(..., ge=0, le=1)
    minor_features_score: float = Field(..., ge=0, le=1)
    optional_features_score: float = Field(..., ge=0, le=1)

    @property
    def confidence_level(self) -> ConfidenceLevel:
        if self.total_score >= 0.85:
            return ConfidenceLevel.CONFIRMED
        elif self.total_score >= 0.60:
            return ConfidenceLevel.SUSPECTED
        return ConfidenceLevel.UNLIKELY

class DiagnosisResult(BaseModel):
    """è¯Šæ–­ç»“æœæ¨¡å‹"""
    diagnosis_id: str = Field(..., pattern=r"^diag_\d{8}_\d{3}$")
    timestamp: datetime

    # è¯Šæ–­ç»“æœ
    disease_id: Optional[str] = None
    disease_name: str
    common_name_en: Optional[str] = None
    pathogen: Optional[str] = None
    level: ConfidenceLevel
    confidence: float = Field(..., ge=0, le=1)

    # ç‰¹å¾å‘é‡
    feature_vector: FeatureVector

    # è¯„åˆ†è¯¦æƒ…
    scores: DiagnosisScore

    # æ¨ç†è¿‡ç¨‹
    reasoning: List[str] = Field(default_factory=list)
    matched_rule: Optional[str] = None

    # å€™é€‰ç–¾ç—…ï¼ˆç–‘ä¼¼è¯Šæ–­æ—¶ï¼‰
    candidates: Optional[List[Dict[str, Any]]] = None

    # æ‰§è¡Œä¿¡æ¯
    vlm_provider: str
    execution_time_ms: int

    # é”™è¯¯ä¿¡æ¯
    error: Optional[str] = None

# domain/disease.py
class DiseaseOntology(BaseModel):
    """ç–¾ç—…æœ¬ä½“æ¨¡å‹"""
    model_config = ConfigDict(validate_assignment=True)

    version: str = "4.1"
    disease_id: str = Field(..., min_length=3, max_length=50)
    disease_name: str = Field(..., min_length=2, max_length=100)
    common_name_en: str
    pathogen: str

    # ç‰¹å¾å‘é‡
    feature_vector: Dict[str, Any]

    # ç‰¹å¾é‡è¦æ€§
    feature_importance: Dict[str, Dict] = Field(...)

    # è¯Šæ–­è§„åˆ™
    diagnosis_rules: Dict[str, List[Dict]] = Field(...)

    # è§†è§‰æè¿°
    visual_descriptions: Dict[str, str] = Field(default_factory=dict)

    # å®¿ä¸»æ¤ç‰©
    host_plants: List[str] = Field(default_factory=list)

    # å…¸å‹ç—‡çŠ¶æè¿°
    typical_symptoms: List[str] = Field(default_factory=list)

    def get_major_features(self) -> List[Dict]:
        """è·å–ä¸»è¦ç‰¹å¾"""
        return self.feature_importance.get("major_features", {}).get("features", [])

    def get_expected_values(self, dimension: str) -> List[str]:
        """è·å–æŸç»´åº¦çš„æœŸæœ›å€¼"""
        for feature_group in self.feature_importance.values():
            for feature in feature_group.get("features", []):
                if feature.get("dimension") == dimension:
                    return feature.get("expected_values", [])
        return []

# domain/plant.py
class PlantOntology(BaseModel):
    """æ¤ç‰©æœ¬ä½“æ¨¡å‹"""
    model_config = ConfigDict(validate_assignment=True)

    # åˆ†ç±»å­¦ä¿¡æ¯
    kingdom: str = "Plantae"
    family: str
    genus: str
    species: List[str] = Field(default_factory=list)
    common_names: Dict[str, str] = Field(default_factory=dict)  # {"zh": "ç«ç‘°", "en": "Rose"}

    # å™¨å®˜è§£å‰–
    organ_anatomy: Dict[str, List[str]] = Field(default_factory=dict)

    # VLMè¯†åˆ«çº¿ç´¢
    visual_cues: Dict[str, str] = Field(default_factory=dict)

    # æ˜“æ„Ÿç–¾ç—…
    susceptible_diseases: List[str] = Field(default_factory=list)

# domain/feature.py
class FeatureOntology(BaseModel):
    """ç‰¹å¾æœ¬ä½“æ¨¡å‹"""
    model_config = ConfigDict(validate_assignment=True)

    version: str = "1.0"

    # ç‰¹å¾ç»´åº¦å®šä¹‰
    dimensions: Dict[str, Dict] = Field(...)

    # æ¨¡ç³ŠåŒ¹é…è§„åˆ™
    fuzzy_matching: Dict[str, Any] = Field(...)

    # ç—‡çŠ¶ç±»å‹å®šä¹‰
    symptom_types: List[Dict[str, str]] = Field(default_factory=list)

    # é¢œè‰²å®šä¹‰
    colors: Dict[str, List[str]] = Field(default_factory=dict)

    # å°ºå¯¸å®šä¹‰
    sizes: List[str] = Field(default_factory=list)

    # åˆ†å¸ƒæ¨¡å¼å®šä¹‰
    distribution_patterns: List[str] = Field(default_factory=list)

# domain/value_objects.py
from dataclasses import dataclass

@dataclass(frozen=True)
class ImageHash:
    """å›¾ç‰‡å“ˆå¸Œå€¼å¯¹è±¡"""
    md5: str
    sha256: Optional[str] = None

    @classmethod
    def from_bytes(cls, image_bytes: bytes) -> "ImageHash":
        import hashlib
        return cls(
            md5=hashlib.md5(image_bytes).hexdigest(),
            sha256=hashlib.sha256(image_bytes).hexdigest()
        )

@dataclass(frozen=True)
class DiagnosisId:
    """è¯Šæ–­IDå€¼å¯¹è±¡"""
    value: str

    def __post_init__(self):
        import re
        if not re.match(r"^diag_\d{8}_\d{3}$", self.value):
            raise ValueError(f"Invalid diagnosis ID format: {self.value}")

    @classmethod
    def generate(cls) -> "DiagnosisId":
        from datetime import datetime
        import random
        date_str = datetime.now().strftime("%Y%m%d")
        seq = random.randint(1, 999)
        return cls(f"diag_{date_str}_{seq:03d}")
```

---

## 8. çŸ¥è¯†æœ¬ä½“è®¾è®¡ï¼ˆJSON Schema + ç¤ºä¾‹ï¼‰

### 8.1 Disease Ontology Schema

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "title": "Disease Ontology Schema",
  "type": "object",
  "required": [
    "version",
    "disease_id",
    "disease_name",
    "feature_vector",
    "feature_importance",
    "diagnosis_rules"
  ],
  "properties": {
    "version": {
      "type": "string",
      "pattern": "^\\d+\\.\\d+$"
    },
    "disease_id": {
      "type": "string",
      "minLength": 3,
      "maxLength": 50
    },
    "disease_name": {
      "type": "string",
      "minLength": 2,
      "maxLength": 100
    },
    "common_name_en": {
      "type": "string"
    },
    "pathogen": {
      "type": "string"
    },
    "feature_vector": {
      "type": "object",
      "properties": {
        "symptom_type": {"type": "string"},
        "color_center": {"type": ["string", "array"]},
        "color_border": {"type": ["string", "array"]},
        "location": {"type": ["string", "array"]},
        "size": {"type": "string"},
        "distribution": {"type": "string"}
      }
    },
    "feature_importance": {
      "type": "object",
      "properties": {
        "major_features": {
          "type": "object",
          "properties": {
            "_weight": {"type": "number"},
            "features": {
              "type": "array",
              "items": {
                "type": "object",
                "required": ["dimension", "expected_values", "weight"],
                "properties": {
                  "dimension": {"type": "string"},
                  "expected_values": {
                    "type": "array",
                    "items": {"type": "string"}
                  },
                  "weight": {"type": "number"},
                  "description": {"type": "string"}
                }
              }
            }
          }
        },
        "minor_features": {
          "type": "object"
        },
        "optional_features": {
          "type": "object"
        }
      }
    },
    "diagnosis_rules": {
      "type": "object"
    },
    "visual_descriptions": {
      "type": "object"
    }
  }
}
```

### 8.2 Disease Ontology ç¤ºä¾‹

```json
{
  "version": "4.1",
  "disease_id": "rose_black_spot",
  "disease_name": "ç«ç‘°é»‘æ–‘ç—…",
  "common_name_en": "Rose Black Spot",
  "pathogen": "Diplocarpon rosae",

  "feature_vector": {
    "symptom_type": "necrosis_spot",
    "color_center": ["black", "dark_brown"],
    "color_border": ["yellow", "light_yellow"],
    "location": ["lamina", "petiole"],
    "size": "medium",
    "distribution": "random"
  },

  "feature_importance": {
    "major_features": {
      "_weight": 0.8,
      "features": [
        {
          "dimension": "symptom_type",
          "expected_values": ["necrosis_spot"],
          "weight": 0.5,
          "description": "åæ­»æ€§æ–‘ç‚¹æ˜¯é»‘æ–‘ç—…çš„å…³é”®ç‰¹å¾"
        },
        {
          "dimension": "color_center",
          "expected_values": ["black", "dark_brown", "brown"],
          "weight": 0.3,
          "description": "é»‘è‰²æˆ–æ·±è¤è‰²ä¸­å¿ƒæ˜¯å…¸å‹ç‰¹å¾"
        }
      ]
    },
    "minor_features": {
      "_weight": 0.15,
      "features": [
        {
          "dimension": "color_border",
          "expected_values": ["yellow", "light_yellow"],
          "weight": 0.1,
          "description": "é»„è‰²æ™•åœˆ"
        },
        {
          "dimension": "location",
          "expected_values": ["lamina", "petiole"],
          "weight": 0.05,
          "description": "ä¸»è¦å‘ç”Ÿåœ¨å¶ç‰‡å’Œå¶æŸ„"
        }
      ]
    },
    "optional_features": {
      "_weight": 0.05,
      "features": [
        {
          "dimension": "size",
          "expected_values": ["medium", "medium_small"],
          "weight": 0.03,
          "description": "æ–‘ç‚¹å¤§å°éšç—…ç¨‹å˜åŒ–"
        },
        {
          "dimension": "distribution",
          "expected_values": ["random", "scattered"],
          "weight": 0.02,
          "description": "éšæœºåˆ†å¸ƒ"
        }
      ]
    }
  },

  "diagnosis_rules": {
    "confirmed": {
      "criteria": [
        {
          "rule_id": "R1",
          "logic": "major_features >= 2/2 AND minor_features >= 1/2",
          "confidence": 0.95,
          "description": "ä¸»è¦ç‰¹å¾å…¨éƒ¨åŒ¹é…ä¸”è‡³å°‘ä¸€ä¸ªæ¬¡è¦ç‰¹å¾åŒ¹é…"
        }
      ]
    },
    "suspected": {
      "criteria": [
        {
          "rule_id": "R2",
          "logic": "major_features >= 1/2 AND minor_features >= 1/2",
          "confidence": 0.70,
          "description": "è‡³å°‘ä¸€ä¸ªä¸»è¦ç‰¹å¾å’Œä¸€ä¸ªæ¬¡è¦ç‰¹å¾åŒ¹é…"
        }
      ]
    }
  },

  "visual_descriptions": {
    "color_border": "è§‚å¯Ÿæ–‘ç‚¹è¾¹ç¼˜ï¼Œå¯»æ‰¾åƒç…è›‹è›‹ç™½ç¯ç»•è›‹é»„çš„é»„è‰²æ™•åœˆ",
    "symptom_appearance": "æ–‘ç‚¹çœ‹èµ·æ¥åƒè¢«é¦™çƒŸçƒ«è¿‡ç•™ä¸‹çš„ç„¦ç—•",
    "progression": "æ—©æœŸä¸ºå°é»‘ç‚¹ï¼ŒåæœŸæ‰©å¤§å¹¶èåˆï¼Œå¯å¯¼è‡´å¶ç‰‡è„±è½"
  }
}
```

### 8.3 Feature Ontology Schema

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "title": "Feature Ontology Schema",
  "type": "object",
  "properties": {
    "version": {"type": "string"},
    "dimensions": {
      "type": "object",
      "properties": {
        "symptom_type": {
          "type": "object",
          "properties": {
            "values": {
              "type": "array",
              "items": {"type": "string"}
            },
            "descriptions": {
              "type": "object"
            }
          }
        },
        "color": {
          "type": "object",
          "properties": {
            "groups": {
              "type": "object",
              "additionalProperties": {
                "type": "array",
                "items": {"type": "string"}
              }
            }
          }
        },
        "size": {
          "type": "object",
          "properties": {
            "order": {
              "type": "array",
              "items": {"type": "string"}
            },
            "visual_references": {
              "type": "object"
            }
          }
        }
      }
    },
    "fuzzy_matching": {
      "type": "object"
    }
  }
}
```

### 8.4 Host-Disease Ontology Schema

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "title": "Host-Disease Associations Schema",
  "type": "object",
  "properties": {
    "version": {"type": "string"},
    "associations": {
      "type": "array",
      "items": {
        "type": "object",
        "required": ["host_genus", "disease_id", "specificity"],
        "properties": {
          "host_genus": {"type": "string"},
          "disease_id": {"type": "string"},
          "specificity": {
            "type": "string",
            "enum": ["species", "genus", "family"]
          },
          "prevalence": {
            "type": "string",
            "enum": ["common", "occasional", "rare"]
          }
        }
      }
    }
  }
}
```

---

## 9. ç¼“å­˜ä¸ Rate Limit ç­–ç•¥

### 9.1 ç¼“å­˜ç­–ç•¥ï¼ˆMVPç®€åŒ–ç‰ˆï¼‰

**ä»…å®ç°VLMå“åº”ç¼“å­˜**ï¼š

```python
# core/cache.py
class RedisCache:
    """Redisç¼“å­˜å°è£…"""

    def __init__(self, redis_url: str):
        self.redis = redis.from_url(redis_url)

    async def get_vlm_response(
        self,
        provider: str,
        image_hash: str,
        question_id: str
    ) -> Optional[str]:
        """è·å–VLMå“åº”ç¼“å­˜"""
        key = f"vlm:{provider}:{image_hash}:{question_id}"
        return await self.redis.get(key)

    async def set_vlm_response(
        self,
        provider: str,
        image_hash: str,
        question_id: str,
        response: str,
        ttl: int = 7 * 24 * 3600  # 7å¤©
    ) -> None:
        """ç¼“å­˜VLMå“åº”"""
        key = f"vlm:{provider}:{image_hash}:{question_id}"
        await self.redis.setex(key, ttl, response)

    async def invalidate_pattern(self, pattern: str) -> int:
        """æ‰¹é‡å¤±æ•ˆç¼“å­˜"""
        keys = await self.redis.keys(pattern)
        if keys:
            return await self.redis.delete(*keys)
        return 0
```

**ç¼“å­˜é”®è®¾è®¡**ï¼š

| ç¼“å­˜ç±»å‹ | é”®æ ¼å¼ | TTL | è¯´æ˜ |
|---------|--------|-----|------|
| VLMå“åº” | `vlm:{provider}:{image_hash}:{question_id}` | 7å¤© | ç¼“å­˜VLMé—®ç­”ç»“æœ |
| çŸ¥è¯†åº“ç‰ˆæœ¬ | `kb:version` | æ°¸ä¹… | å½“å‰çŸ¥è¯†åº“ç‰ˆæœ¬ |
| è¯Šæ–­ç»“æœ | `diag:{diagnosis_id}` | 30å¤© | ç¼“å­˜å®Œæ•´è¯Šæ–­ç»“æœ |

### 9.2 Rate Limitç­–ç•¥ï¼ˆMVPä¸å®ç°ï¼‰

MVPé˜¶æ®µä¿¡ä»»ç”¨æˆ·ï¼Œä¸å®ç°Rate Limitã€‚

æœªæ¥æ‰©å±•ï¼ˆv1.2+ï¼‰ï¼š
- åŸºäºAPI Keyçš„é™æµ
- ä½¿ç”¨æ»‘åŠ¨çª—å£ç®—æ³•
- æ¯ä¸ªKeyæ¯åˆ†é’Ÿ20æ¬¡è¯·æ±‚

---

## 10. å¤šç§Ÿæˆ·ä¸æƒé™è®¾è®¡

### 10.1 æƒé™æ¨¡å‹ï¼ˆMVPç®€åŒ–ç‰ˆï¼‰

**å•ç§Ÿæˆ·æ¶æ„ï¼Œä¸¤çº§æƒé™**ï¼š

```python
# æƒé™çº§åˆ«
class UserRole(str, Enum):
    API_USER = "api_user"    # æ™®é€šç”¨æˆ·ï¼šè°ƒç”¨è¯Šæ–­API
    ADMIN = "admin"          # ç®¡ç†å‘˜ï¼šæ‰€æœ‰æƒé™

# æƒé™çŸ©é˜µ
PERMISSION_MATRIX = {
    UserRole.API_USER: [
        "diagnose:execute",
        "history:read_own"
    ],
    UserRole.ADMIN: [
        "diagnose:execute",
        "history:read_all",
        "knowledge:read",
        "knowledge:write",
        "knowledge:reload",
        "statistics:read",
        "apikey:manage"
    ]
}
```

### 10.2 è®¤è¯å®ç°

```python
# middleware/auth.py
class APIKeyMiddleware:
    """API KeyéªŒè¯ä¸­é—´ä»¶"""

    async def __call__(self, request: Request, call_next):
        # è·³è¿‡ä¸éœ€è¦è®¤è¯çš„è·¯å¾„
        if request.url.path in ["/docs", "/openapi.json", "/health"]:
            return await call_next(request)

        # æ£€æŸ¥API Key
        api_key = request.headers.get("X-API-Key")
        if not api_key:
            return JSONResponse(
                status_code=401,
                content={"error": "Missing API Key"}
            )

        # éªŒè¯API Key
        key_info = await verify_api_key(api_key)
        if not key_info or not key_info.is_active:
            return JSONResponse(
                status_code=401,
                content={"error": "Invalid API Key"}
            )

        # æ³¨å…¥ç”¨æˆ·ä¿¡æ¯
        request.state.user = key_info

        return await call_next(request)
```

### 10.3 ç®¡ç†åå°è®¤è¯

```python
# admin/utils/auth.py
def check_admin_auth():
    """Streamlitç®¡ç†åå°è®¤è¯"""
    if 'authenticated' not in st.session_state:
        st.session_state.authenticated = False

    if not st.session_state.authenticated:
        with st.form("login_form"):
            username = st.text_input("ç”¨æˆ·å")
            password = st.text_input("å¯†ç ", type="password")
            submitted = st.form_submit_button("ç™»å½•")

            if submitted:
                # éªŒè¯ç”¨æˆ·åå¯†ç 
                if verify_admin_credentials(username, password):
                    st.session_state.authenticated = True
                    st.session_state.username = username
                    st.rerun()
                else:
                    st.error("ç”¨æˆ·åæˆ–å¯†ç é”™è¯¯")
        return False

    return True
```

---

## 11. æµ‹è¯•ç­–ç•¥

### 11.1 å•å…ƒæµ‹è¯•ç­–ç•¥

**æµ‹è¯•è¦†ç›–ç‡ç›®æ ‡**ï¼šæ ¸å¿ƒæ¨¡å— â‰¥ 80%

**é‡ç‚¹æµ‹è¯•æ¨¡å—**ï¼š
- `FuzzyMatcher`: é¢œè‰²/å°ºå¯¸æ¨¡ç³ŠåŒ¹é…é€»è¾‘
- `DiagnosisScorer`: åŠ æƒè¯„åˆ†ç®—æ³•
- `VLMClient`: Fallbackæœºåˆ¶
- `FeatureVector`: æ•°æ®éªŒè¯

**æµ‹è¯•ç¤ºä¾‹**ï¼š

```python
# tests/unit/test_matcher.py
import pytest
from infrastructure.ontology.matcher import FuzzyMatcher

class TestFuzzyMatcher:
    @pytest.fixture
    def matcher(self):
        return FuzzyMatcher()

    def test_color_exact_match(self, matcher):
        """æµ‹è¯•é¢œè‰²ç²¾ç¡®åŒ¹é…"""
        assert matcher.match_color("black", "black") == True
        assert matcher.match_color("black", "white") == False

    def test_color_group_match(self, matcher):
        """æµ‹è¯•åŒè‰²ç³»åŒ¹é…"""
        assert matcher.match_color("black", "dark_brown") == True
        assert matcher.match_color("yellow", "light_yellow") == True
        assert matcher.match_color("black", "yellow") == False

    def test_size_fuzzy_match(self, matcher):
        """æµ‹è¯•å°ºå¯¸æ¨¡ç³ŠåŒ¹é…ï¼ˆÂ±1çº§åˆ«ï¼‰"""
        assert matcher.match_size("medium", "medium") == True
        assert matcher.match_size("medium", "medium_small") == True
        assert matcher.match_size("medium", "large") == True
        assert matcher.match_size("small", "large") == False
```

### 11.2 é›†æˆæµ‹è¯•ç­–ç•¥

**æµ‹è¯•åœºæ™¯**ï¼š
- å®Œæ•´è¯Šæ–­æµç¨‹ï¼ˆå›¾ç‰‡ä¸Šä¼ â†’ç‰¹å¾æå–â†’ç–¾ç—…åŒ¹é…â†’ç»“æœè¿”å›ï¼‰
- çŸ¥è¯†åº“çƒ­æ›´æ–°ï¼ˆä¿®æ”¹JSONâ†’è§¦å‘é‡è½½â†’éªŒè¯ç”Ÿæ•ˆï¼‰
- VLMé™çº§æµç¨‹ï¼ˆä¸»Providerå¤±è´¥â†’è‡ªåŠ¨åˆ‡æ¢â†’è¿”å›ç»“æœï¼‰

```python
# tests/integration/test_diagnosis_api.py
@pytest.mark.asyncio
async def test_complete_diagnosis_flow():
    """æµ‹è¯•å®Œæ•´è¯Šæ–­æµç¨‹"""
    async with AsyncClient(app=app, base_url="http://test") as client:
        # å‡†å¤‡æµ‹è¯•å›¾ç‰‡
        with open("tests/fixtures/rose_black_spot.jpg", "rb") as f:
            files = {"image": ("test.jpg", f, "image/jpeg")}

        # å‘é€è¯Šæ–­è¯·æ±‚
        response = await client.post(
            "/api/v1/diagnose",
            files=files,
            headers={"X-API-Key": "test_key"}
        )

        # éªŒè¯å“åº”
        assert response.status_code == 200
        data = response.json()
        assert data["diagnosis"]["disease_id"] == "rose_black_spot"
        assert data["diagnosis"]["level"] == "confirmed"
        assert data["diagnosis"]["confidence"] >= 0.85
```

### 11.3 E2Eæµ‹è¯•ç­–ç•¥

ä½¿ç”¨Playwrightæµ‹è¯•Webç•Œé¢ï¼š

```python
# tests/e2e/test_diagnosis_flow.py
from playwright.async_api import async_playwright

async def test_web_diagnosis_flow():
    """æµ‹è¯•Webè¯Šæ–­å®Œæ•´æµç¨‹"""
    async with async_playwright() as p:
        browser = await p.chromium.launch()
        page = await browser.new_page()

        # è®¿é—®è¯Šæ–­é¡µé¢
        await page.goto("http://localhost:3000/diagnose")

        # ä¸Šä¼ å›¾ç‰‡
        await page.set_input_files(
            'input[type="file"]',
            "tests/fixtures/rose_black_spot.jpg"
        )

        # ç‚¹å‡»è¯Šæ–­æŒ‰é’®
        await page.click('button:has-text("å¼€å§‹è¯Šæ–­")')

        # ç­‰å¾…ç»“æœ
        await page.wait_for_selector(".diagnosis-result", timeout=30000)

        # éªŒè¯ç»“æœæ˜¾ç¤º
        result_text = await page.text_content(".disease-name")
        assert "ç«ç‘°é»‘æ–‘ç—…" in result_text

        await browser.close()
```

---

## 12. æµ‹è¯•ç”¨ä¾‹è¡¨æ ¼

| ID | ç±»å‹ | æè¿° | å‰ç½®æ¡ä»¶ | è¾“å…¥ | é¢„æœŸè¾“å‡º | è¦†ç›–ç‚¹ |
|----|------|------|----------|------|----------|--------|
| TC01 | åŠŸèƒ½ | æ­£å¸¸è¯Šæ–­æµç¨‹ | ç³»ç»Ÿæ­£å¸¸è¿è¡Œ | ç«ç‘°é»‘æ–‘ç—…å›¾ç‰‡ | è¿”å›confirmedè¯Šæ–­ï¼Œconfidenceâ‰¥0.85 | å®Œæ•´è¯Šæ–­æµç¨‹ |
| TC02 | è¾¹ç•Œ | Q0.0éæ¤ç‰©å›¾ç‰‡ | ç³»ç»Ÿæ­£å¸¸è¿è¡Œ | åŠ¨ç‰©å›¾ç‰‡ | è¿”å›"ä¸æ”¯æŒçš„å›¾ç‰‡ç±»å‹" | Q0å†…å®¹ç±»å‹è¿‡æ»¤ |
| TC03 | è¾¹ç•Œ | Q0.1éèŠ±å‰æ¤ç‰© | ç³»ç»Ÿæ­£å¸¸è¿è¡Œ | è”¬èœå›¾ç‰‡ | è¿”å›"ä»…æ”¯æŒèŠ±å‰ç–¾ç—…è¯Šæ–­" | Q0æ¤ç‰©ç±»åˆ«è¿‡æ»¤ |
| TC04 | è¾¹ç•Œ | Q0.2æœªè¯†åˆ«èŠ±å± | ç³»ç»Ÿæ­£å¸¸è¿è¡Œ | æœªçŸ¥èŠ±å‰å›¾ç‰‡ | è¿”å›genus="Other" | Q0èŠ±å±è¯†åˆ« |
| TC05 | è¾¹ç•Œ | Q0.5å¥åº·æ ·æœ¬ | ç³»ç»Ÿæ­£å¸¸è¿è¡Œ | å¥åº·ç«ç‘°å›¾ç‰‡ | è¿”å›"æœªå‘ç°å¼‚å¸¸" | Q0å¼‚å¸¸åˆ¤æ–­ |
| TC06 | åŠŸèƒ½ | Q1ç—‡çŠ¶ç±»å‹necrosis | ç³»ç»Ÿæ­£å¸¸è¿è¡Œ | åæ­»æ–‘ç‚¹å›¾ç‰‡ | symptom_type="necrosis_spot" | Q1åŠ¨æ€ç‰¹å¾æå– |
| TC07 | åŠŸèƒ½ | Q1ç—‡çŠ¶ç±»å‹powdery | ç³»ç»Ÿæ­£å¸¸è¿è¡Œ | ç™½ç²‰ç—…å›¾ç‰‡ | symptom_type="powdery_coating" | Q1åˆ†æ”¯é€»è¾‘ |
| TC08 | ç®—æ³• | é«˜ç½®ä¿¡åº¦è¯Šæ–­ | ç‰¹å¾å®Œå…¨åŒ¹é… | å…¸å‹é»‘æ–‘ç—…å›¾ç‰‡ | level="confirmed", scoreâ‰¥0.85 | ç½®ä¿¡åº¦åˆ†å±‚å†³ç­– |
| TC09 | ç®—æ³• | ä¸­ç½®ä¿¡åº¦è¯Šæ–­ | éƒ¨åˆ†ç‰¹å¾åŒ¹é… | æ¨¡ç³Šç—‡çŠ¶å›¾ç‰‡ | level="suspected", 0.6â‰¤score<0.85 | ç–‘ä¼¼è¯Šæ–­é€»è¾‘ |
| TC10 | ç®—æ³• | ä½ç½®ä¿¡åº¦VLMå…œåº• | çŸ¥è¯†åº“å¤–ç–¾ç—… | æœªçŸ¥ç–¾ç—…å›¾ç‰‡ | è°ƒç”¨VLMå¼€æ”¾è¯Šæ–­ï¼Œæ ‡è®°"VLMæ¨æµ‹" | VLMå…œåº•ç­–ç•¥ |
| TC11 | ç³»ç»Ÿ | çŸ¥è¯†åº“çƒ­æ›´æ–° | ç®¡ç†å‘˜æƒé™ | POST /admin/reload | æ–°ç‰ˆæœ¬ç«‹å³ç”Ÿæ•ˆ | çƒ­æ›´æ–°æœºåˆ¶ |
| TC12 | å®¹é”™ | VLMè¶…æ—¶é™çº§ | Qwenä¸å¯ç”¨ | è¯Šæ–­è¯·æ±‚ | è‡ªåŠ¨åˆ‡æ¢åˆ°ChatGPT | Fallbackæœºåˆ¶ |
| TC13 | ç®—æ³• | é¢œè‰²æ¨¡ç³ŠåŒ¹é… | é¢œè‰²è§‚å¯Ÿè¯¯å·® | observed="dark_brown", expected="black" | åŒ¹é…æˆåŠŸï¼ˆåŒè‰²ç³»ï¼‰ | COLOR_GROUPS |
| TC14 | ç®—æ³• | å°ºå¯¸æ¨¡ç³ŠåŒ¹é… | å°ºå¯¸è§‚å¯Ÿè¯¯å·® | observed="medium_small", expected="medium" | åŒ¹é…æˆåŠŸï¼ˆÂ±1çº§åˆ«ï¼‰ | SIZE_ORDER |
| TC15 | ç®—æ³• | Majorç‰¹å¾æƒé‡è®¡ç®— | ä¸»è¦ç‰¹å¾åŒ¹é… | symptom_typeåŒ¹é… | major_score += 0.5 | åŠ æƒè¯„åˆ†0.8 |
| TC16 | ç®—æ³• | Minorç‰¹å¾æƒé‡è®¡ç®— | æ¬¡è¦ç‰¹å¾åŒ¹é… | locationåŒ¹é… | minor_score += 0.1 | åŠ æƒè¯„åˆ†0.15 |
| TC17 | ç®—æ³• | Optionalç‰¹å¾æƒé‡ | å¯é€‰ç‰¹å¾åŒ¹é… | sizeåŒ¹é… | optional_score += 0.03 | åŠ æƒè¯„åˆ†0.05 |
| TC18 | åŠŸèƒ½ | ç®¡ç†åå°ç–¾ç—…ç¼–è¾‘ | ç®¡ç†å‘˜ç™»å½• | ä¿®æ”¹ç–¾ç—…JSON | ä¿å­˜æˆåŠŸï¼Œé‡è½½ç”Ÿæ•ˆ | çŸ¥è¯†åº“ç®¡ç† |
| TC19 | è¾¹ç•Œ | é”™è¯¯å›¾ç‰‡æ ¼å¼ | ç³»ç»Ÿæ­£å¸¸è¿è¡Œ | BMPæ ¼å¼å›¾ç‰‡ | è¿”å›400é”™è¯¯ | æ ¼å¼éªŒè¯ |
| TC20 | å®¹é”™ | æ•°æ®åº“è¿æ¥å¤±è´¥ | PGæœåŠ¡åœæ­¢ | è¯Šæ–­è¯·æ±‚ | è¿”å›503æœåŠ¡ä¸å¯ç”¨ | æ•°æ®åº“å®¹é”™ |
| TC21 | å®‰å…¨ | API KeyéªŒè¯-æœ‰æ•ˆ | æœ‰æ•ˆKey | Headerå«X-API-Key | è¯·æ±‚æˆåŠŸ | è®¤è¯æœºåˆ¶ |
| TC22 | å®‰å…¨ | API KeyéªŒè¯-æ— æ•ˆ | æ— æ•ˆKey | é”™è¯¯çš„API Key | è¿”å›401æœªæˆæƒ | è®¤è¯æ‹’ç» |
| TC23 | å®‰å…¨ | API KeyéªŒè¯-ç¼ºå¤± | æ— Header | ç¼ºå°‘X-API-Key | è¿”å›401 | è®¤è¯æ£€æŸ¥ |
| TC24 | åŠŸèƒ½ | å›¾ç‰‡å­˜å‚¨åˆ†ç±» | è¯Šæ–­å®Œæˆ | ç«ç‘°å›¾ç‰‡ | å­˜å‚¨åˆ°unlabeled/rose/ç›®å½• | å­˜å‚¨ç­–ç•¥ |
| TC25 | åŠŸèƒ½ | å†å²æŸ¥è¯¢-æŒ‰æ—¥æœŸ | æœ‰å†å²è®°å½• | start_date, end_date | è¿”å›æ—¥æœŸèŒƒå›´å†…è®°å½• | æŸ¥è¯¢åŠŸèƒ½ |
| TC26 | åŠŸèƒ½ | å†å²æŸ¥è¯¢-æŒ‰æ¤ç‰© | æœ‰å†å²è®°å½• | plant_genus="Rosa" | è¿”å›ç«ç‘°ç›¸å…³è®°å½• | ç­›é€‰é€»è¾‘ |
| TC27 | åŠŸèƒ½ | å†å²æŸ¥è¯¢-æŒ‰ç½®ä¿¡åº¦ | æœ‰å†å²è®°å½• | level="confirmed" | è¿”å›ç¡®è¯Šè®°å½• | ç½®ä¿¡åº¦ç­›é€‰ |
| TC28 | å¹¶å‘ | 10ä¸ªå¹¶å‘è¯Šæ–­ | ç³»ç»Ÿæ­£å¸¸è¿è¡Œ | 10ä¸ªå¹¶å‘è¯·æ±‚ | å…¨éƒ¨æˆåŠŸï¼Œæ— å†²çª | å¹¶å‘å¤„ç† |
| TC29 | ç®—æ³• | å®Œæ•´æ€§ä¿®æ­£complete | completeå›¾ç‰‡ | completeness="complete" | modifier=1.0 | å®Œæ•´æ€§ç³»æ•° |
| TC30 | ç®—æ³• | å®Œæ•´æ€§ä¿®æ­£partial | éƒ¨åˆ†å›¾ç‰‡ | completeness="partial" | modifier=0.8 | éƒ¨åˆ†ä¿®æ­£ |
| TC31 | ç®—æ³• | å®Œæ•´æ€§ä¿®æ­£close_up | ç‰¹å†™å›¾ç‰‡ | completeness="close_up" | modifier=0.6,è·³è¿‡åˆ†å¸ƒ | ç‰¹å†™å¤„ç† |
| TC32 | åŠŸèƒ½ | Q0æ–°å¢å­—æ®µè¾“å‡º | è¯Šæ–­å®Œæˆ | ä»»æ„å›¾ç‰‡ | feature_vectorå«content_typeç­‰ | ç‰¹å¾å‘é‡å®Œæ•´æ€§ |
| TC33 | æ€§èƒ½ | è¯Šæ–­å»¶è¿ŸP95 | ç³»ç»Ÿæ­£å¸¸ | 100æ¬¡è¯Šæ–­è¯·æ±‚ | P95å»¶è¿Ÿâ‰¤30ç§’ | æ€§èƒ½æŒ‡æ ‡ |
| TC34 | å®¹é”™ | VLMå…¨éƒ¨å¤±è´¥ | æ‰€æœ‰Providerä¸å¯ç”¨ | è¯Šæ–­è¯·æ±‚ | è¿”å›"VLMæœåŠ¡ä¸å¯ç”¨"é”™è¯¯ | æç«¯å®¹é”™ |
| TC35 | åŠŸèƒ½ | ç¼“å­˜å‘½ä¸­ | ç›¸åŒå›¾ç‰‡äºŒæ¬¡è¯Šæ–­ | é‡å¤çš„å›¾ç‰‡+é—®é¢˜ | ä»ç¼“å­˜è¿”å›ï¼Œ<1ç§’å“åº” | VLMç¼“å­˜æœºåˆ¶ |

---

## 13. éƒ¨ç½²ä¸ CI/CD æ–¹æ¡ˆ

### 13.1 å¼€å‘ç¯å¢ƒéƒ¨ç½²

**ç¯å¢ƒå‡†å¤‡**ï¼š

```bash
# 1. å®‰è£…PostgreSQL 15
brew install postgresql@15  # macOS
sudo apt install postgresql-15  # Ubuntu

# 2. å®‰è£…Redis
brew install redis  # macOS
sudo apt install redis-server  # Ubuntu

# 3. åˆ›å»ºæ•°æ®åº“
createdb phytooracle_dev

# 4. åˆå§‹åŒ–è¡¨ç»“æ„
psql phytooracle_dev < backend/scripts/init_db.sql
```

**åç«¯å¯åŠ¨**ï¼š

```bash
cd backend

# å®‰è£…ä¾èµ–
poetry install

# é…ç½®ç¯å¢ƒå˜é‡
cp .env.example .env
# ç¼–è¾‘.envï¼Œå¡«å†™æ•°æ®åº“è¿æ¥ã€VLM API Keyç­‰

# è¿è¡ŒæœåŠ¡
python -m apps.api.main
# æˆ–ä½¿ç”¨uvicornçƒ­é‡è½½
uvicorn apps.api.main:app --reload --host 0.0.0.0 --port 8000
```

**å‰ç«¯å¯åŠ¨**ï¼š

```bash
cd frontend

# å®‰è£…ä¾èµ–
npm install

# å¯åŠ¨å¼€å‘æœåŠ¡å™¨
npm run dev
# è®¿é—® http://localhost:3000
```

**ç®¡ç†åå°**ï¼š

```bash
cd backend

# å¯åŠ¨Streamlit
streamlit run apps/admin/app.py --server.port 8501
# è®¿é—® http://localhost:8501
```

### 13.2 ç”Ÿäº§ç¯å¢ƒéƒ¨ç½²

**æœåŠ¡å™¨è¦æ±‚**ï¼š
- CPU: 4æ ¸+
- å†…å­˜: 8GB+
- ç¡¬ç›˜: 100GB+
- OS: Ubuntu 22.04 LTS

**éƒ¨ç½²æ­¥éª¤**ï¼š

```bash
# 1. å…‹éš†ä»£ç 
git clone https://github.com/yourorg/phytooracle.git
cd phytooracle

# 2. å®‰è£…ç³»ç»Ÿä¾èµ–
sudo apt update
sudo apt install -y python3.10 python3.10-venv postgresql-15 redis-server nginx

# 3. åˆ›å»ºè™šæ‹Ÿç¯å¢ƒ
python3.10 -m venv venv
source venv/bin/activate

# 4. å®‰è£…Pythonä¾èµ–
cd backend
pip install -r requirements.txt

# 5. é…ç½®æ•°æ®åº“
sudo -u postgres createuser phytooracle
sudo -u postgres createdb -O phytooracle phytooracle_prod
psql -U phytooracle phytooracle_prod < scripts/init_db.sql

# 6. é…ç½®ç¯å¢ƒå˜é‡
cp .env.example .env.production
# ç¼–è¾‘é…ç½®æ–‡ä»¶

# 7. å¯åŠ¨åç«¯æœåŠ¡ï¼ˆä½¿ç”¨Supervisorç®¡ç†ï¼‰
sudo cp deploy/supervisor/phytooracle.conf /etc/supervisor/conf.d/
sudo supervisorctl reread
sudo supervisorctl update
sudo supervisorctl start phytooracle:*

# 8. æ„å»ºå‰ç«¯
cd ../frontend
npm install
npm run build

# 9. é…ç½®Nginx
sudo cp deploy/nginx/phytooracle.conf /etc/nginx/sites-available/
sudo ln -s /etc/nginx/sites-available/phytooracle.conf /etc/nginx/sites-enabled/
sudo nginx -s reload
```

**Nginxé…ç½®ç¤ºä¾‹**ï¼š

```nginx
# /etc/nginx/sites-available/phytooracle.conf
upstream backend {
    server 127.0.0.1:8000;
    server 127.0.0.1:8001;
    server 127.0.0.1:8002;
    server 127.0.0.1:8003;
}

server {
    listen 80;
    server_name api.phytooracle.com;

    # APIè½¬å‘
    location /api/ {
        proxy_pass http://backend;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;

        # è¶…æ—¶è®¾ç½®ï¼ˆVLMè°ƒç”¨å¯èƒ½è¾ƒæ…¢ï¼‰
        proxy_connect_timeout 60s;
        proxy_send_timeout 60s;
        proxy_read_timeout 60s;
    }

    # é™æ€æ–‡ä»¶
    location / {
        root /var/www/phytooracle/frontend/out;
        try_files $uri $uri.html $uri/ =404;
    }

    # ç®¡ç†åå°
    location /admin/ {
        proxy_pass http://127.0.0.1:8501/;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection "upgrade";
    }
}
```

**Supervisoré…ç½®**ï¼š

```ini
# /etc/supervisor/conf.d/phytooracle.conf
[group:phytooracle]
programs=backend-8000,backend-8001,backend-8002,backend-8003

[program:backend-8000]
command=/home/phytooracle/venv/bin/uvicorn apps.api.main:app --host 127.0.0.1 --port 8000
directory=/home/phytooracle/backend
user=phytooracle
autostart=true
autorestart=true
stdout_logfile=/var/log/phytooracle/backend-8000.log
stderr_logfile=/var/log/phytooracle/backend-8000-error.log

# ç±»ä¼¼é…ç½®8001-8003ç«¯å£...
```

### 13.3 CI/CDæ–¹æ¡ˆï¼ˆMVPæ‰‹å·¥éƒ¨ç½²ï¼‰

MVPé˜¶æ®µé‡‡ç”¨æ‰‹å·¥éƒ¨ç½²ï¼Œæ­¥éª¤ï¼š

```bash
# 1. æœ¬åœ°æµ‹è¯•é€šè¿‡
pytest backend/tests/

# 2. æ¨é€ä»£ç 
git add .
git commit -m "feat: xxx"
git push origin main

# 3. æœåŠ¡å™¨æ‹‰å–æ›´æ–°
ssh phytooracle@server
cd /home/phytooracle
git pull origin main

# 4. æ›´æ–°ä¾èµ–ï¼ˆå¦‚éœ€è¦ï¼‰
source venv/bin/activate
pip install -r backend/requirements.txt

# 5. é‡å¯æœåŠ¡
sudo supervisorctl restart phytooracle:*

# 6. éªŒè¯æœåŠ¡
curl http://localhost:8000/health
```

**æœªæ¥CI/CDæ”¹è¿›ï¼ˆv1.3+ï¼‰**ï¼š
- ä½¿ç”¨GitHub Actionsè‡ªåŠ¨åŒ–æµ‹è¯•
- Dockerå®¹å™¨åŒ–éƒ¨ç½²
- è“ç»¿éƒ¨ç½²ç­–ç•¥
- è‡ªåŠ¨å›æ»šæœºåˆ¶

---

## 14. æœªæ¥æ‰©å±•ç‚¹æ¸…å•

### 14.1 åŠŸèƒ½æ‰©å±•ï¼ˆv1.2ï¼‰

| æ‰©å±•é¡¹ | ä¼˜å…ˆçº§ | é¢„ä¼°å·¥æ—¶ | ä»·å€¼ |
|--------|--------|----------|------|
| **å¤šç§Ÿæˆ·éš”ç¦»** | P1 | 80h | æ”¯æŒSaaSå¤šå®¢æˆ· |
| **Dockerå®¹å™¨åŒ–** | P1 | 40h | ç®€åŒ–éƒ¨ç½²è¿ç»´ |
| **Rate Limit** | P2 | 20h | é˜²æ­¢APIæ»¥ç”¨ |
| **å›¾ç‰‡å»é‡ç¼“å­˜** | P2 | 16h | èŠ‚çœVLMæˆæœ¬ |
| **æ‰¹é‡è¯Šæ–­API** | P2 | 24h | æå‡æ•ˆç‡ |
| **WebSocketè¿›åº¦æ¨é€** | P3 | 32h | æ”¹å–„ç”¨æˆ·ä½“éªŒ |

### 14.2 åŠŸèƒ½æ‰©å±•ï¼ˆv1.3+ï¼‰

| æ‰©å±•é¡¹ | ä¼˜å…ˆçº§ | é¢„ä¼°å·¥æ—¶ | ä»·å€¼ |
|--------|--------|----------|------|
| **æ”¯ä»˜ä¸é…é¢ç®¡ç†** | P1 | 120h | å•†ä¸šåŒ–èƒ½åŠ› |
| **CI/CDè‡ªåŠ¨åŒ–** | P1 | 40h | æå‡å‘å¸ƒæ•ˆç‡ |
| **å¼‚æ­¥ä»»åŠ¡é˜Ÿåˆ—** | P2 | 60h | æ”¯æŒå¤§æ‰¹é‡å¤„ç† |
| **Treatment Ontology** | P2 | 80h | è¯Šæ–­-æ²»ç–—é—­ç¯ |
| **ç§»åŠ¨ç«¯SDK** | P3 | 160h | æ‰©å±•ä½¿ç”¨åœºæ™¯ |
| **å¤šè¯­è¨€æ”¯æŒ** | P3 | 80h | å›½é™…åŒ– |

### 14.3 æŠ€æœ¯å€ºåŠ¡æ¸…ç†

- å®Œå–„å•å…ƒæµ‹è¯•è¦†ç›–ç‡åˆ°90%+
- é‡æ„VLM Promptç®¡ç†
- ä¼˜åŒ–çŸ¥è¯†åº“åŠ è½½æ€§èƒ½
- ç»Ÿä¸€é”™è¯¯å¤„ç†æœºåˆ¶
- æ·»åŠ æ€§èƒ½ç›‘æ§ï¼ˆAPMï¼‰
- å®ç°æ—¥å¿—èšåˆåˆ†æ

### 14.4 çŸ¥è¯†åº“æ‰©å±•è®¡åˆ’

**v1.2ç›®æ ‡**ï¼ˆåŸºäºæ•°æ®é›†ï¼‰ï¼š
- Hibiscusï¼ˆæœ¨æ§¿ï¼‰- 4ç§ç–¾ç—…
- Crape Jasmineï¼ˆç‹—ç‰™èŠ±ï¼‰- 3ç§ç–¾ç—…
- Night-flowering Jasmineï¼ˆå¤œæ¥é¦™ï¼‰- 3ç§ç–¾ç—…
- Dwarf White Bauhiniaï¼ˆç¾Šè¹„ç”²ï¼‰- 3ç§ç–¾ç—…

**v1.3ç›®æ ‡**ï¼ˆå¸‚åœºéœ€æ±‚ï¼‰ï¼š
- å…°èŠ±å±ï¼ˆOrchidaceaeï¼‰- é«˜ç«¯å¸‚åœº
- èŠèŠ±å±ï¼ˆChrysanthemumï¼‰- å¤§ä¼—å¸‚åœº
- ç™¾åˆå±ï¼ˆLiliumï¼‰- é²œåˆ‡èŠ±å¸‚åœº

---

## æ–‡æ¡£ä¿®è®¢è®°å½•

| ç‰ˆæœ¬ | æ—¥æœŸ | ä¿®è®¢å†…å®¹ | ä½œè€… |
|-----|------|---------|------|
| v1.0 | 2025-11-11 | åˆå§‹ç‰ˆæœ¬ï¼Œå®Œæˆ14ç« èŠ‚è¯¦ç»†è®¾è®¡ | ç³»ç»Ÿæ¶æ„å¸ˆ |

---
